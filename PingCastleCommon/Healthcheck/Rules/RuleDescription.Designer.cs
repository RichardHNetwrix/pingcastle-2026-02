//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PingCastleCommon.Healthcheck.Rules {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class RuleDescription {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal RuleDescription() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("PingCastleCommon.Healthcheck.Rules.RuleDescription", typeof(RuleDescription).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there are no rogue admin accounts in the Active Directory.
        /// </summary>
        public static string A_AdminSDHolder_Description {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string A_AdminSDHolder_Detail {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/win32/adschema/a-admincount.
        /// </summary>
        public static string A_AdminSDHolder_Documentation {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Suspicious admin activities detected on {count} user(s).
        /// </summary>
        public static string A_AdminSDHolder_Rationale {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#admincountequalsone&quot;&gt;AdminSDHolder User List&lt;/a&gt;.
        /// </summary>
        public static string A_AdminSDHolder_ReportLocation {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to These accounts should be reviewed, especially in regards with their past activities and have the admincount attribute removed. In order to identify which accounts are detected by this rule, we advise to run a PowerShell command that will show you all users having this flag set: &lt;i&gt;get-adobject -ldapfilter &quot;(admincount=1)&quot;&lt;/i&gt;
        ///    Do not forget to look at the section AdminSDHolder below..
        /// </summary>
        public static string A_AdminSDHolder_Solution {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A check is performed on non-admin accounts in order to identify if they have an attribute &lt;i&gt;admincount&lt;/i&gt; set. If they have this attribute, it means that this account, which is not supposed to be admin, has been granted administrator rights in the past. This typically happens when an administrator gives temporary rights to a normal account, off process..
        /// </summary>
        public static string A_AdminSDHolder_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for suspicious account(s) used in administrator activities.
        /// </summary>
        public static string A_AdminSDHolder_Title {
            get {
                return ResourceManager.GetString("A_AdminSDHolder_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains having a GPO which allows access to the domain without any account .
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Description {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Detail {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc963223%28v%3dtechnet.10%29
        ///        https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj852184(v=ws.11%29.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Documentation {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} policies have been found where anonymous accesses can be used.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Rationale {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_ReportLocation {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to remove the anonymous access, we advise to identify the GPO indicated by the program and change the setting restrictanonymous and restrictanonymoussam.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Solution {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is possible that domains are set to authorize connection without any account, which represents a security breach. It allows potential attackers to enumerate all the users and computers belonging to a domain, in order to identify very efficiently future weak targets.
        ///It is possible to verify the results provided by the PingCastle solution by using a Kali Linux distribution. You should run [rpcclient -U &apos;&apos; -N target_ip_address] to finally type [enumdomusers]..
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for GPO granting access to the domain without any account.
        /// </summary>
        public static string A_AnonymousAuthorizedGPO_Title {
            get {
                return ResourceManager.GetString("A_AnonymousAuthorizedGPO_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the audit policy on domain controllers collects the right set of events..
        /// </summary>
        public static string A_AuditDC_Description {
            get {
                return ResourceManager.GetString("A_AuditDC_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type: {0} Audit: {1} Problem: {2} Rationale: {3} Domain controller: {4}.
        /// </summary>
        public static string A_AuditDC_Detail {
            get {
                return ResourceManager.GetString("A_AuditDC_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://adsecurity.org/?p=3299
        ///https://adsecurity.org/?p=3377.
        /// </summary>
        public static string A_AuditDC_Documentation {
            get {
                return ResourceManager.GetString("A_AuditDC_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The audit policy on domain controllers does not collect key events..
        /// </summary>
        public static string A_AuditDC_Rationale {
            get {
                return ResourceManager.GetString("A_AuditDC_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#auditsettings&quot;&gt;Audit settings&lt;/a&gt;
        ///    &lt;br&gt;
        ///    The table below shows the settings that were not found as configured in a GPO for a given domain controller..
        /// </summary>
        public static string A_AuditDC_ReportLocation {
            get {
                return ResourceManager.GetString("A_AuditDC_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identify the Audit settings to apply and fix them.
        ///    Be aware that there are two places for audit settings.
        ///    For &quot;Simple&quot; audit configuration:
        ///    in Computer Configuration -&gt; Policies -&gt; Windows Settings -&gt; Security Settings -&gt; Local Policies -&gt; Audit Policies
        ///    For &quot;Advanced&quot; audit configuration:
        ///    in Computer Configuration -&gt; Policies -&gt; Windows Settings -&gt; Security Settings -&gt; Advanced Audit Policy Configuration
        ///    Also be sure that the audit GPO is applied to all domain controllers, as  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_AuditDC_Solution {
            get {
                return ResourceManager.GetString("A_AuditDC_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To detect and mitigate an attack, the right set of events need to be collected.
        ///      The audit policy is a compromise between too much and too few events to collect.
        ///      To solve this problem, the suggested audit policy from adsecurity.org is checked against the audit policy in place.
        ///    .
        /// </summary>
        public static string A_AuditDC_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_AuditDC_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is the expected audit policy on domain controllers..
        /// </summary>
        public static string A_AuditDC_Title {
            get {
                return ResourceManager.GetString("A_AuditDC_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that PowerShell logging is enabled..
        /// </summary>
        public static string A_AuditPowershell_Description {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_AuditPowershell_Detail {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://adsecurity.org/?p=2604
        ///https://learn.microsoft.com/en-us/powershell/scripting/wmf/whats-new/script-logging?view=powershell-6.
        /// </summary>
        public static string A_AuditPowershell_Documentation {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The PowerShell audit configuration is not fully enabled..
        /// </summary>
        public static string A_AuditPowershell_Rationale {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_AuditPowershell_ReportLocation {
            get {
                return ResourceManager.GetString("A_AuditPowershell_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Go to Computer Configuration -&gt; Administrative Templates -&gt; Windows Components -&gt; Windows PowerShell
        ///And enable &quot;Turn on Module logging&quot; and &quot;Turn on PowerShell Script Block logging&quot;
        ///We recommend to set &quot;*&quot; as the module list.
        ///  .
        /// </summary>
        public static string A_AuditPowershell_Solution {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PowerShell is a powerful language, also used by hackers because of this quality. Hackers are able to run programs such as mimikatz in memory using obfuscated commands such as Invoke-Mimikatz.
        ///    Because there is no artefact on the disk, the incident response task is difficult for the forensic analysts.
        ///    For this reason, we recommend to enable PowerShell logging via a group policy, despite the fact that these security settings may be part of the workstation or server images.
        ///    .
        /// </summary>
        public static string A_AuditPowershell_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_AuditPowershell_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if PowerShell logging is enabled..
        /// </summary>
        public static string A_AuditPowershell_Title {
            get {
                return ResourceManager.GetString("A_AuditPowershell_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if the backups are actually up to date in case they are needed. The alert can be triggered when a domain is backed up using non-recommended methods.
        /// </summary>
        public static string A_BackupMetadata_Description {
            get {
                return ResourceManager.GetString("A_BackupMetadata_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/jj130668(v=ws.10).
        /// </summary>
        public static string A_BackupMetadata_Documentation {
            get {
                return ResourceManager.GetString("A_BackupMetadata_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last AD backup has been performed {count} day(s) ago.
        /// </summary>
        public static string A_BackupMetadata_Rationale {
            get {
                return ResourceManager.GetString("A_BackupMetadata_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Recovery for Active Directory| enables scheduled backups to ensure compliance, and provides automated rapid recovery to minimize downtime..
        /// </summary>
        public static string A_BackupMetadata_RelevantProducts {
            get {
                return ResourceManager.GetString("A_BackupMetadata_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#backup&quot;&gt;Backup&lt;/a&gt;.
        /// </summary>
        public static string A_BackupMetadata_ReportLocation {
            get {
                return ResourceManager.GetString("A_BackupMetadata_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Plan AD backups based on Microsoft standards. These standards depend on the Operating System. For example with the wbadmin utility: &lt;i&gt;wbadmin start systemstatebackup -backuptarget:d:&lt;/i&gt;.
        /// </summary>
        public static string A_BackupMetadata_Solution {
            get {
                return ResourceManager.GetString("A_BackupMetadata_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A verification is done on the backups, ensuring that the backup is performed according to Microsoft standards. Indeed, at each backup the DIT Database Partition Backup Signature is updated. If for any reasons, backups are needed to perform a rollback (rebuild a domain) or to track past changes, the backups will actually be up to date. This check is equivalent to a &lt;i&gt;REPADMIN /showbackup *&lt;/i&gt;..
        /// </summary>
        public static string A_BackupMetadata_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_BackupMetadata_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for the last backup date according to Microsoft standard.
        /// </summary>
        public static string A_BackupMetadata_Title {
            get {
                return ResourceManager.GetString("A_BackupMetadata_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to One or more Organizational Units (OUs) in your Active Directory domain have delegations granting non-privileged users or groups the ability to create or control msDS-DelegatedManagedServiceAccount objects.
        /// </summary>
        public static string A_BadSuccessor_Description {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Principal: {0} Permission: {1} OU: {2}.
        /// </summary>
        public static string A_BadSuccessor_Detail {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.akamai.com/blog/security-research/abusing-dmsa-for-privilege-escalation-in-active-directory#badsuccessor.
        /// </summary>
        public static string A_BadSuccessor_Documentation {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to BadSuccessor Delegation Detected: {count}.
        /// </summary>
        public static string A_BadSuccessor_Rationale {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review the affected OUs and restrict delegations that grant non-privileged users or groups permissions such as Create All Child Objects, WriteDACL, WriteOwner, or FullControl over msDS-DelegatedManagedServiceAccount objects. Only highly trusted administrators should have these rights..
        /// </summary>
        public static string A_BadSuccessor_Solution {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule detects when non-privileged users or groups are granted dangerous permissions over msDS-DelegatedManagedServiceAccount (dMSA) objects in OUs, specifically in environments with Windows Server 2025 Domain Controllers. Such delegations enable attackers to exploit the &quot;BadSuccessor&quot; vulnerability through two primary attack vectors: membership hijacking and cryptographic key extraction.
        ///
        ///In membership hijacking attacks, attackers can forge the msDS-ManagedAccountPrecededByLink attribute to migrate gr [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_BadSuccessor_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_BadSuccessor_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to BadSuccessor Delegation Detected.
        /// </summary>
        public static string A_BadSuccessor_Title {
            get {
                return ResourceManager.GetString("A_BadSuccessor_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if the Extended protection for HTTPS access to the certificate enrollment interface is in place.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Description {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Server: {0} Service: {1}.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Detail {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://support.microsoft.com/en-us/topic/kb5005413-mitigating-ntlm-relay-attacks-on-active-directory-certificate-services-ad-cs-3612b773-4043-4aa9-b23d-b87910cd3429
        ///https://dirkjanm.io/ntlm-relaying-to-ad-certificate-services/
        ///https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Documentation {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Channel Binding is not enforced for the HTTPS certificate enrollment interface.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Rationale {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Extended Protection for Authentication (EPA, also called Channel Binding) should be activated on the enrollment server.
        ///    
        ///    This can be achieved by opening the IIS console on the enrollment server.
        ///    In the Authentcation settings, open the Advanced Settings for the Windows Authentication.
        ///    Set &quot;Extended Protection&quot; to &quot;Required&quot;.
        ///    
        ///    Do this operation for the Certification Authority Web Enrollment (WebEnrollment) and Certificate Enrollment Web Service (CES).
        ///    
        ///    See the link  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Solution {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows PKI, also named Active Directory Certificate Services (ADCS), can be used to request certificates.
        ///Two services can be used: Certification Authority Web Enrollment (WebEnrollment) and Certificate Enrollment Web Service (CES).
        ///The certificates provided by these services can be used with Kerberos to login.
        ///    
        /// Because this service can deliver certificates for Domain Controller, it can be considered as part of Tier 0.
        ///As a legacy service, the mechanisms to prohibit credential relay are not e [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertEnrollChannelBinding_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if Extended Protection is in place for certificate requests.
        /// </summary>
        public static string A_CertEnrollChannelBinding_Title {
            get {
                return ResourceManager.GetString("A_CertEnrollChannelBinding_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if HTTP can be used to access the certificate enrollment interface.
        /// </summary>
        public static string A_CertEnrollHttp_Description {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Server: {0} Service: {1}.
        /// </summary>
        public static string A_CertEnrollHttp_Detail {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://support.microsoft.com/en-us/topic/kb5005413-mitigating-ntlm-relay-attacks-on-active-directory-certificate-services-ad-cs-3612b773-4043-4aa9-b23d-b87910cd3429
        ///https://dirkjanm.io/ntlm-relaying-to-ad-certificate-services/
        ///https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/
        ///https://www.vkernel.ro/blog/installing-and-configuring-cep-and-ces-for-certificate-enrolling-on-non-domain-joined-computers.
        /// </summary>
        public static string A_CertEnrollHttp_Documentation {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The certificate enrollment interface is accessible by unencrypted HTTP.
        /// </summary>
        public static string A_CertEnrollHttp_Rationale {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The access to certificate enrollment with HTTP should be disabled.
        ///    
        ///This can be achieved by opening the IIS console on the enrollment server.
        ///If the service quoted in detail is WebEnrollment, the url is certsrv, else it is ending by CES_Keberos.
        ///
        ///In the Binding setting (link at the right), keep the HTTPS binding and remove the HTTP binding.
        ///See the link to KB5005413 in references for more information.
        ///    
        ///Note: By default, the CES service is not accessible by HTTP.
        ///  .
        /// </summary>
        public static string A_CertEnrollHttp_Solution {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows PKI, also named Active Directory Certificate Services (ADCS), can be used to request certificates.
        ///Two services can be used: Certification Authority Web Enrollment (WebEnrollment) and Certificate Enrollment Web Service (CES).
        ///The certificates provided by these services can be used with Kerberos to login.
        ///    
        ///Because this service can deliver certificates for Domain Controllers, it can be considered as part of Tier 0.
        ///As a legacy service, the mechanisms to prohibit credential relay are not e [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertEnrollHttp_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if certificate enrollment can be done with HTTP.
        /// </summary>
        public static string A_CertEnrollHttp_Title {
            get {
                return ResourceManager.GetString("A_CertEnrollHttp_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no private key that can be recovered from a certificate.
        /// </summary>
        public static string A_CertROCA_Description {
            get {
                return ResourceManager.GetString("A_CertROCA_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Source: {0} Subject: {1} Expires: {2}.
        /// </summary>
        public static string A_CertROCA_Detail {
            get {
                return ResourceManager.GetString("A_CertROCA_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://crocs.fi.muni.cz/public/papers/rsa_ccs17
        ///https://github.com/crocs-muni/roca
        ///https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV190026
        ///https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV170012
        ///https://keychest.net/roca.
        /// </summary>
        public static string A_CertROCA_Documentation {
            get {
                return ResourceManager.GetString("A_CertROCA_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one private key associated to a certificate can be recovered.
        /// </summary>
        public static string A_CertROCA_Rationale {
            get {
                return ResourceManager.GetString("A_CertROCA_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks certificate template changes to protect against unauthorized modifications and ensure security..
        /// </summary>
        public static string A_CertROCA_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertROCA_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_CertROCA_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertROCA_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the certificates listed below are still valid, you have to revoke and re-issue them. If other certificates depend on them, they should be revoked and replaced too.
        ///    If the certificates have been expired, they should be removed..
        /// </summary>
        public static string A_CertROCA_Solution {
            get {
                return ResourceManager.GetString("A_CertROCA_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &quot;ROCA&quot; is an acronym for &quot;Return of Coppersmith&apos;s attack&quot; which enables an attacker to retrieve the private key from a public key.
        ///    It is due by a library named RSALib, provided by Infineon Technologies which is incorporated into many smart cards, Trusted Platform Module (TPM), and Hardware Security Modules (HSM) implementations, including YubiKey 4 tokens and used to generate public RSA keys.
        ///  This library was generating data in a limited number space, which decreased the number of values that an att [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertROCA_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertROCA_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for the ROCA vulnerability in certificates.
        /// </summary>
        public static string A_CertROCA_Title {
            get {
                return ResourceManager.GetString("A_CertROCA_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose of this rule is to ensure that there is no agent certificate that can be requested by anyone.
        /// </summary>
        public static string A_CertTempAgent_Description {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Name: {0}.
        /// </summary>
        public static string A_CertTempAgent_Detail {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://posts.specterops.io/certified-pre-owned-d95910965cd2
        ///https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/.
        /// </summary>
        public static string A_CertTempAgent_Documentation {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one certificate template can be used to issue agent certificate to everyone [{count}].
        /// </summary>
        public static string A_CertTempAgent_Rationale {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks certificate template changes to protect against unauthorized modifications and ensure security..
        /// </summary>
        public static string A_CertTempAgent_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertTempAgent_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificatetemplates&quot;&gt;Certificate Templates&lt;/a&gt;.
        /// </summary>
        public static string A_CertTempAgent_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertTempAgent_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review the permissions that allow a wide enrollment of this certificate template
        ///    .
        /// </summary>
        public static string A_CertTempAgent_Solution {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An Agent certificate is a special certificate used to request certificates on behalf of other users.
        ///    A template has been detected with the agent EKU and that can be enrolled by a large number of users..
        /// </summary>
        public static string A_CertTempAgent_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertTempAgent_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the permission of agent certificate templates.
        /// </summary>
        public static string A_CertTempAgent_Title {
            get {
                return ResourceManager.GetString("A_CertTempAgent_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose of this rule is to ensure that there is no certificate template that can be edited by anyone.
        /// </summary>
        public static string A_CertTempAnyone_Description {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Name: {0}.
        /// </summary>
        public static string A_CertTempAnyone_Detail {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://posts.specterops.io/certified-pre-owned-d95910965cd2
        ///https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/.
        /// </summary>
        public static string A_CertTempAnyone_Documentation {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one certificate template can be modified by everyone [{count}].
        /// </summary>
        public static string A_CertTempAnyone_Rationale {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| protects your environment by monitoring and optionally blocking unauthorized changes to certificate templates, ensuring security..
        /// </summary>
        public static string A_CertTempAnyone_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificatetemplates&quot;&gt;Certificate Templates&lt;/a&gt;.
        /// </summary>
        public static string A_CertTempAnyone_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review the security permissions of this certificate template and remove the write access to everyone-like groups such as Domain Users, Domain Computers, Everyone, Authenticated Users, ...
        ///    .
        /// </summary>
        public static string A_CertTempAnyone_Solution {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A certificate template is an object whose definition serves as a base to issue certificates.
        ///    If a user has the right to edit it, it can manually change obscure attributes such as msPKI-Certificate-Name-Flag.
        ///    Doing so will enable him to provide the subject of the certificate and thus having a certificate on behalf other users such as admins.
        ///  It can be used to impersonate them and take control of the domain.
        ///  
        ///Note: the program regards the group &quot;Domain Computers&quot; like &quot;Everyone&quot; if ms-DS-Mach [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertTempAnyone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if certificate templates can be edited by everyone..
        /// </summary>
        public static string A_CertTempAnyone_Title {
            get {
                return ResourceManager.GetString("A_CertTempAnyone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check verifies whether certificate templates in Active Directory Certificate Services (AD CS) have the &quot;Any Purpose&quot; Enhanced Key Usage (EKU) or lack an EKU entirely, potentially enabling privilege escalation or misuse..
        /// </summary>
        public static string A_CertTempAnyPurpose_Description {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;{0}&gt;Name: {1} &lt;{2}&gt;CA: {3} EnrollmentPrincipals: {4} LastModified: {5}.
        /// </summary>
        public static string A_CertTempAnyPurpose_Detail {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://posts.specterops.io/certified-pre-owned-d95910965cd2
        ///https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/.
        /// </summary>
        public static string A_CertTempAnyPurpose_Documentation {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one certificate template can be requested by everyone having any purpose [{count}].
        /// </summary>
        public static string A_CertTempAnyPurpose_Rationale {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| protects your environment by monitoring and optionally blocking unauthorized changes to certificate templates, ensuring security..
        /// </summary>
        public static string A_CertTempAnyPurpose_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificatetemplates&quot;&gt;Certificate Templates&lt;/a&gt;.
        /// </summary>
        public static string A_CertTempAnyPurpose_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to   There are multiple ways in which remediation of this issue can be completed. It involves restricting the template in one or more ways using the instructions below.
        ///  &lt;ol&gt;&lt;li&gt;Open Certificate Authority (certsrv.msc) and connect to the CA&lt;/li&gt;&lt;li&gt;Navigate to Certificate Templates, right-click and select Manage&lt;/li&gt;&lt;li&gt;Right-click the vulnerable template, and select Properties&lt;/li&gt;&lt;/ol&gt;
        ///  &lt;strong&gt;Option 1 - Restrict Enrolment Permissions&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;  Note:&lt;/strong&gt; This option is the best option t [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertTempAnyPurpose_Solution {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to   Enhanced Key Usage (EKU) defines the intended purpose of a certificate. ESC2 arises when the following EKUs are defined along with other vulnerable criteria that enable low privileged users to request the certificate with no oversight.
        ///  &lt;ul&gt;&lt;li&gt;&quot;Any Purpose&quot; EKU is enabled: This allows the certificate to be used for any purpose, including unintended ones such as authentication or code signing.&lt;/li&gt;&lt;li&gt;No EKU defined: Certificates without an EKU are treated as having &quot;Any Purpose,&quot; making them similarly  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertTempAnyPurpose_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for ESC2: Vulnerable EKU Configurations in Certificate Templates.
        /// </summary>
        public static string A_CertTempAnyPurpose_Title {
            get {
                return ResourceManager.GetString("A_CertTempAnyPurpose_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check verifies if certificate templates in Active Directory Certificate Services (AD CS) allow user-controlled subject information and meet other common criteria associated with the ESC1 vulnerability..
        /// </summary>
        public static string A_CertTempCustomSubject_Description {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;{0}&gt;Name: {1} &lt;{2}&gt;CA: {3} EnrollmentPrincipals: {4} LastModified: {5}.
        /// </summary>
        public static string A_CertTempCustomSubject_Detail {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certified-PreOwned https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf.
        /// </summary>
        public static string A_CertTempCustomSubject_Documentation {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one certificate template used for authentication can have its subject modified when being used [{count}].
        /// </summary>
        public static string A_CertTempCustomSubject_Rationale {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks certificate template changes to protect against unauthorized modifications and ensure security..
        /// </summary>
        public static string A_CertTempCustomSubject_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificatetemplates&quot;&gt;Certificate Templates&lt;/a&gt;.
        /// </summary>
        public static string A_CertTempCustomSubject_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To mitigate ESC1, use one or more of the options below:
        ///
        ///&lt;strong&gt;Option 1: Modify Certificate Template Settings in ADCS&lt;/strong&gt;
        ///&lt;ul&gt;&lt;li&gt;Open Certificate Authority (certsrv.msc) on the CA server.&lt;/li&gt;&lt;li&gt;Right-click on Certificate Templates and select Manage.&lt;/li&gt;&lt;li&gt;Navigate to and right-click the vulnerable template and select Properties.&lt;/li&gt;&lt;li&gt;Go to the Subject Name tab:&lt;ul&gt;&lt;li&gt;Ensure &quot;Supply in the request&quot; is unchecked.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Click OK to save changes.&lt;/li&gt;&lt;/ul&gt;
        ///&lt;strong&gt;Option 2: Restr [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertTempCustomSubject_Solution {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ESC1 is a vulnerability in Active Directory Certificate Services (AD CS) that occurs when certificate templates allow users to control the Subject Name as well as meet other criteria, such as:
        ///&lt;ul&gt;&lt;li&gt;&lt;strong&gt;User-Controlled Subject Name:&lt;/strong&gt; Requesters can define the subject, enabling impersonation of any account in the domain.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Excessive Enrollment Permissions:&lt;/strong&gt; Large groups such as Domain Users and Authenticated Users have enrollment rights on vulnerable templates as well as  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_CertTempCustomSubject_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for ESC1: Vulnerable Subject Control in Certificate Templates.
        /// </summary>
        public static string A_CertTempCustomSubject_Title {
            get {
                return ResourceManager.GetString("A_CertTempCustomSubject_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose of this rule is to ensure that no certificate request templates allow users to control the subject.
        /// </summary>
        public static string A_CertTempNoSecurity_Description {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Name: {0}.
        /// </summary>
        public static string A_CertTempNoSecurity_Detail {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4
        ///https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26931.
        /// </summary>
        public static string A_CertTempNoSecurity_Documentation {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one certificate template has the flag CT_FLAG_NO_SECURITY_EXTENSION set.
        /// </summary>
        public static string A_CertTempNoSecurity_Rationale {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks certificate template changes to protect against unauthorized modifications and ensure security..
        /// </summary>
        public static string A_CertTempNoSecurity_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificatetemplates&quot;&gt;Certificate Templates&lt;/a&gt;.
        /// </summary>
        public static string A_CertTempNoSecurity_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the certificate template object and specifically the attribute msPKI-Enrollment-Flag.
        ///     Unset the flag CT_FLAG_NO_SECURITY_EXTENSION (0x80000) aka substract the value 524288 from the attribute msPKI-Enrollment-Flag.
        ///    .
        /// </summary>
        public static string A_CertTempNoSecurity_Solution {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certificate requests are tracked by UPN and dnsHost name for computers.
        ///    Usually, editing dnsHost change the value of the attribute servicePrincipalName and duplications are prohibited.
        ///  But there is no constraint on the dnsHost attribute and a controlled change of this attribute (without changing the SPN) can lead to duplicates.
        ///An attacker can then change the DNS of a compromise host to the DC DNS and request a certificate on behalf the DC, thus impersonating it and controlling the domain..
        /// </summary>
        public static string A_CertTempNoSecurity_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if authentication certificate templates disallow the tracking of the certificate requester.
        /// </summary>
        public static string A_CertTempNoSecurity_Title {
            get {
                return ResourceManager.GetString("A_CertTempNoSecurity_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of a certificate using a DSA key for signature.
        /// </summary>
        public static string A_CertWeakDSA_Description {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_CertWeakDSA_Detail {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://csrc.nist.gov/publications/detail/fips/186/5/draft.
        /// </summary>
        public static string A_CertWeakDSA_Documentation {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted certificate found has a DSA key [{count}].
        /// </summary>
        public static string A_CertWeakDSA_Rationale {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks certificate template changes to protect against unauthorized modifications and ensure security..
        /// </summary>
        public static string A_CertWeakDSA_RelevantProducts {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_CertWeakDSA_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_CertWeakDSA_Solution {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Digital Signature Algorithm (DSA), is a NIST standard signature algorithm, part of the 1993 Digital Signature Standard(FIPS 186). The proposed FIPS 186-5 draft deprecates the use of DSA and will forbid its usage for digital signature purposes.
        ///    The annex E of FIPS 186-5 specifies: DSA is no longer approved for digital signature generation. DSA may be used to verify signatures generated prior to the implementation date of this standard..
        /// </summary>
        public static string A_CertWeakDSA_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Certificates using the DSA algorithm for signature.
        /// </summary>
        public static string A_CertWeakDSA_Title {
            get {
                return ResourceManager.GetString("A_CertWeakDSA_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of a certificate with a weak RSA exponent.
        /// </summary>
        public static string A_CertWeakRsaComponent_Description {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1} Exponent: {2}.
        /// </summary>
        public static string A_CertWeakRsaComponent_Detail {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_CertWeakRsaComponent_Documentation {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted certificate found has a weak RSA exponent [{count}].
        /// </summary>
        public static string A_CertWeakRsaComponent_Rationale {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_CertWeakRsaComponent_ReportLocation {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_CertWeakRsaComponent_Solution {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The RSA public key is composed of two parts: The modulus and the exponent. The exponent must be a prime number and its value is usually 65537.
        ///    It is not recommended to have a exponent larger than 65537 for compatibility reasons as for example older Windows handle the exponent in 4 bytes.
        ///  Having a lower exponent, such as 3, gives a significant performance boost (up to 8 times), but it is considered less secure..
        /// </summary>
        public static string A_CertWeakRsaComponent_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Certificates using a weak RSA exponent.
        /// </summary>
        public static string A_CertWeakRsaComponent_Title {
            get {
                return ResourceManager.GetString("A_CertWeakRsaComponent_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The objective is to assess the vulnerability of the Domain Controller (DC) to Coerce attacks..
        /// </summary>
        public static string A_DC_Coerce_Description {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DCName: {0} IP: {1} Interface: {2} Function: {3} OpNum: {4}.
        /// </summary>
        public static string A_DC_Coerce_Detail {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/p0dalirius/Coercer
        ///https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-restrict-ntlm-outgoing-ntlm-traffic-to-remote-servers
        ///https://blog.nviso.eu/2023/12/08/rpc-or-not-here-we-log-preventing-exploitation-and-abuse-with-rpc-firewall/.
        /// </summary>
        public static string A_DC_Coerce_Documentation {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to RPC interfaces of DC are likely vulnerable to coercion attacks. Identified interfaces: {count}.
        /// </summary>
        public static string A_DC_Coerce_Rationale {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_DC_Coerce_ReportLocation {
            get {
                return ResourceManager.GetString("A_DC_Coerce_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To effectively mitigate the vulnerability, consider one of the following approaches:
        ///
        ///1. Apply Group Policy Object (GPO) - &quot;Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers&quot;:
        ///Apply this GPO specifically to the Organizational Unit (OU) &quot;Domain Controllers&quot;.
        ///Caution: Enabling this GPO might impact services dependent on NTLM such as files copy Backups.
        ///Consider setting the GPO in &quot;Audit mode&quot; initially to identify and assess the impact on affected services.
        ///
        ///2. Enable RPC Filters [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DC_Coerce_Solution {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Coerce attacks are a category of attacks which aims to forcing domain controllers to authenticate to a device controlled by the attacker for the purpose to relay this authentication to gain privileges.
        ///    This category of attacks is usually mitigated by  applying patch (PetitPotam), disabling services (Spooler), added RPC filter (EDR or firewall) or ensuring integrity (SMB integrity).
        ///  Because each of these protections can be individually bypassed (NTLM integrity is disabled on LDAPS), the aim of this s [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DC_Coerce_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DC_Coerce_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to RPC interfaces potentially vulnerable to Coerce attacks.
        /// </summary>
        public static string A_DC_Coerce_Title {
            get {
                return ResourceManager.GetString("A_DC_Coerce_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that credentials cannot be extracted from the DC via its Print Spooler service.
        /// </summary>
        public static string A_DC_Spooler_Description {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_DC_Spooler_Detail {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://adsecurity.org/?p=4056
        ///https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory.
        /// </summary>
        public static string A_DC_Spooler_Documentation {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The spooler service is remotely accessible from {count} DC.
        /// </summary>
        public static string A_DC_Spooler_Rationale {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_DC_Spooler_ReportLocation {
            get {
                return ResourceManager.GetString("A_DC_Spooler_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Print Spooler service should be deactivated on domain controllers. Please note as a consequence that the Printer Pruning functionality (rarely used) will be unavailable..
        /// </summary>
        public static string A_DC_Spooler_Solution {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When there&apos;s an account with unconstrained delegation configured (which is fairly common) and the Print Spooler service running on a computer, you can get that computers credentials sent to the system with unconstrained delegation as a user. With a domain controller, the TGT of the DC can be extracted allowing an attacker to reuse it with a DCSync attack and obtain all user hashes and impersonate them..
        /// </summary>
        public static string A_DC_Spooler_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DC_Spooler_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the Print Spooler service cannot be abused to get the DC credentials.
        /// </summary>
        public static string A_DC_Spooler_Title {
            get {
                return ResourceManager.GetString("A_DC_Spooler_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that DC cannot connect with normal command line to a HTTP server.
        /// </summary>
        public static string A_DC_WebClient_Description {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_DC_WebClient_Detail {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://gist.github.com/gladiatx0r/1ffe59031d42c08603a3bde0ff678feb#rpc-to-rce-steps.
        /// </summary>
        public static string A_DC_WebClient_Documentation {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The WebClient service which allows WebDAV communication is enabled on {count} DC.
        /// </summary>
        public static string A_DC_WebClient_Rationale {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_DC_WebClient_ReportLocation {
            get {
                return ResourceManager.GetString("A_DC_WebClient_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the WebClient service is in official use (typically from backup applications), disable the service..
        /// </summary>
        public static string A_DC_WebClient_Solution {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, Windows computers supports only UNC paths (aka \\server\path).
        ///    The WebDAV protocol, implemented with HTTP, enables files on webserver to be managed as on a classic file share.
        ///    The role of the WebClient service is to provide as a native API call a service to manage files located on a WebDAV server (HTTP URLs).
        ///    If the WebClient service is active, command line tools and services can access files on a webserver without any specifc action.
        /// 
        ///    When forced authentication attacks are [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DC_WebClient_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DC_WebClient_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the WebClient client cannot be abused to force a DC connection to a HTTP server.
        /// </summary>
        public static string A_DC_WebClient_Title {
            get {
                return ResourceManager.GetString("A_DC_WebClient_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if the Channel Binding feature of LDAPS is enforced.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Description {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Detail {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://support.microsoft.com/en-us/topic/use-the-ldapenforcechannelbinding-registry-entry-to-make-ldap-authentication-over-ssl-tls-more-secure-e9ecfa27-5e57-8519-6ba3-d2c06b21812e
        ///https://support.microsoft.com/en-us/topic/2020-2023-and-2024-ldap-channel-binding-and-ldap-signing-requirements-for-windows-kb4520412-ef185fb8-00f7-167d-744c-f299a66fc00a
        ///https://oxfordcomputergroup.com/resources/ldap-channel-binding-signing-requirements/
        ///https://github.com/zyn3rgy/LdapRelayScan
        ///https://access.redhat.com/arti [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Documentation {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Channel binding is not enabled for all DC for LDAPS.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Rationale {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to make sure that ALL LDAPS clients are compatible with Channel Binding.
        ///All supported Windows have been updated since March 2020 to take this into account and also most of the Unix clients (see the RedHat bulletin link below).
        ///
        ///You can start auditing via registry, on each domain controller
        ///Reg Add HKLM\SYSTEM\CurrentControlSet\Services\NTDS\Diagnostics /v &quot;16 LDAP Interface Events&quot; /t REG_DWORD /d 2
        ///Then monitor the Windows event IDs 3039 and 3040.
        ///
        ///Once it has been verified that all client [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Solution {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAPS (opposed to LDAP) does not allow message signature because this protection is made by the TLS layer.
        ///As a consequence, forged LDAP packets can be relayed in a TLS tunnel, thus becoming LDAPS and without any protection against relay.
        ///
        ///To avoid this attack, a feature named Channel Binding exists. It consists of passing to the authentication layer a property of the TLS channel (typically a hash of the server certificate) to bind the outer channel (TLS) and the inner channel (LDAP).
        ///This protection is [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapsChannelBinding_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the Channel Binding is enabled for LDAPS.
        /// </summary>
        public static string A_DCLdapsChannelBinding_Title {
            get {
                return ResourceManager.GetString("A_DCLdapsChannelBinding_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if signing is really required for LDAP.
        /// </summary>
        public static string A_DCLdapSign_Description {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_DCLdapSign_Detail {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-US/troubleshoot/windows-server/identity/enable-ldap-signing-in-windows-server
        ///https://support.microsoft.com/en-us/topic/2020-2023-and-2024-ldap-channel-binding-and-ldap-signing-requirements-for-windows-kb4520412-ef185fb8-00f7-167d-744c-f299a66fc00a
        ///https://github.com/zyn3rgy/LdapRelayScan.
        /// </summary>
        public static string A_DCLdapSign_Documentation {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A LDAP authentication without signature enforcement was allowed.
        /// </summary>
        public static string A_DCLdapSign_Rationale {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to make sure that ALL LDAP clients are compatible with LDAP signature.
        ///All versions of Windows since XP support this and also most of the Unix clients.
        ///
        ///You have to follow the Microsoft article quoted in reference to enable LDAP signing.
        ///This includes auditing the clients which are not compatible and instructions on how to enforce this policy..
        /// </summary>
        public static string A_DCLdapSign_Solution {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the the request for signing of each LDAP request is not enforced, a man in the middle can be performed on an LDAP connection.
        ///For example to add a user to the admin group.
        ///    
        ///This test is made by ignoring the local computer security policies.
        ///Signature enforcement is done by setting the flag ISC_REQ_INTEGRITY when initializig the Negotiate / NTLM / Kerberos authentication.
        ///The opposite test is made with the flag ISC_REQ_NO_INTEGRITY set.
        ///    
        ///PingCastle is testing if this setting is in place by  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapSign_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DCLdapSign_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if signing is really required for LDAP.
        /// </summary>
        public static string A_DCLdapSign_Title {
            get {
                return ResourceManager.GetString("A_DCLdapSign_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all DC don&apos;t use weak SSL protocols when acting as server..
        /// </summary>
        public static string A_DCLdapsProtocol_Description {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC: {0} Protocol: {1}.
        /// </summary>
        public static string A_DCLdapsProtocol_Detail {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/technet-wiki/2249.windows-server-20082008r2-how-to-disable-sslv2-on-domain-controller-dsforum2wiki
        ///https://learn.microsoft.com/en-us/dotnet/framework/network-programming/tls#configuring-schannel-protocols-in-the-windows-registry
        ///https://adsecurity.org/?p=376.
        /// </summary>
        public static string A_DCLdapsProtocol_Documentation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one DC uses a weak SSL protocol for server-side purposes..
        /// </summary>
        public static string A_DCLdapsProtocol_Rationale {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_DCLdapsProtocol_ReportLocation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Apply Windows updates and registry tweaks described in the documentation section to disable the weak SSL protocols.
        ///  .
        /// </summary>
        public static string A_DCLdapsProtocol_Solution {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SSL version 2 and SSL version 3 are considered broken and it is strongly advised to disable them.
        ///    The SSL protocols in Windows is provided by the SChannel component.
        ///The SChannel component needs to be tuned in order to not propose these weak protocols. Many guidelines to handle this problem issued by Microsoft do not talk about SChannel but rather IIS. These guidlines are quoted in the documentation section below.
        ///
        ///PingCastle is able to check the SSL version if LDAPS is exposed. LDAPS is automatical [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapsProtocol_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if LDAPS is used with weak SSL protocol..
        /// </summary>
        public static string A_DCLdapsProtocol_Title {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocol_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all DC are using the most advanced protocols when acting as server..
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Description {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC: {0} Protocol: {1}.
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Detail {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://support.microsoft.com/en-us/topic/kb5017811-manage-transport-layer-security-tls-1-0-and-1-1-after-default-behavior-change-on-september-20-2022-e95b1b47-9c7c-4d64-9baf-610604a64c3e
        ///https://learn.microsoft.com/en-us/dotnet/framework/network-programming/tls#configuring-schannel-protocols-in-the-windows-registry.
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Documentation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one DC is using Tls1.0 or Tls1.1..
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Rationale {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_ReportLocation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Apply Windows updates and registry tweaks described in the documentation section to use Tls 1.2 and later.
        ///  .
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Solution {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TLS 1.0 and TLS 1.1 are no longer recommended to use, even if there is no pratical attack to could lead to an immediate compromise of the DC.
        ///The SChannel component needs to be tuned in order to not propose these protocols. Many guidelines to handle this problem issued by Microsoft do not talk about SChannel but rather IIS. These guidlines are quoted in the documentation section below.
        ///
        ///PingCastle is able to check the SSL version if LDAPS is exposed. LDAPS is automatically exposed once a certificate is a [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if LDAPS is using Tls 1.0 or Tls 1.1..
        /// </summary>
        public static string A_DCLdapsProtocolAdvanced_Title {
            get {
                return ResourceManager.GetString("A_DCLdapsProtocolAdvanced_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check that the computer account password can be changed as usual..
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Description {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Detail {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/domain-controller-refuse-machine-account-password-changes.
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Documentation {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one GPO disables explicitly the change of the computer account password.
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Rationale {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_ReportLocation {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the GPO specified in Details and change the setting in &quot;Domain controller: Refuse machine account password changes&quot;.
        ///    Disable this setting, or set it to &quot;Disabled&quot;.
        ///The setting is located in :
        ///    Computer configuration -&gt; Policies -&gt; Windows Settings -&gt;Security Settings -&gt; Local Policies -&gt; Security Options.
        ///As an alternative, the file GptTmpl.inf can be manually edited..
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Solution {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to For each computer, there is a hidden user account. This account is used to maintain the computer inside the Active Directory domain.
        ///    The password of this account is changed every 30 days automatically except if the Domain Controller prohibits this.
        ///  This is the case when this GPO setting is enabled..
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that Domain Controllers don&apos;t deny the change of computer account passwords..
        /// </summary>
        public static string A_DCRefuseComputerPwdChange_Title {
            get {
                return ResourceManager.GetString("A_DCRefuseComputerPwdChange_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if Authenticated Users has the right to create DNS records.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Description {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DNSZone: {0}.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Detail {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.ws-its.de/gegenmassnahme-zum-angriff-dns-wildcard/
        ///https://www.netspi.com/blog/technical/network-penetration-testing/exploiting-adidns/.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Documentation {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Authenticated Users can create DNS records.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Rationale {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to As of today, this rule is considered &quot;informative&quot; because the default configuration where Authenticated Users can create DNS records is considered safe.
        ///  The reason for this classification is that no exploitation of that vulnerability has been reported.
        ///    
        ///The proposed enhancement is to replace the identity who has been granted the right to create DNS Records (permission CreateChild) from Authenticated Users to Domain Computers.
        ///To perform this change, you have to edit the permission of the DNSZone  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Solution {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a computer is joined to a domain, a DNS record is created in the DnsZone to allow the computer to update its DNS settings.
        ///    By design, Microsoft choose to grant to the group Authenticated Users (aka every computers and users) the right to create DNS records.
        ///    Once created, only the owner keeps the right to edit the new object.
        ///    
        ///    The vulnerability is that specific DNS records can be created to perform man-in-the-middle attacks.
        ///    One example is to create a wildcard record (a record w [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if Authenticated Users can create DNS records.
        /// </summary>
        public static string A_DnsZoneAUCreateChild_Title {
            get {
                return ResourceManager.GetString("A_DnsZoneAUCreateChild_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no DNS Zones are configured with Zone Transfers..
        /// </summary>
        public static string A_DnsZoneTransfert_Description {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zone: {0}.
        /// </summary>
        public static string A_DnsZoneTransfert_Detail {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/f97756c9-3783-428b-9451-b376f877319a
        ///    https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/dnscmd.
        /// </summary>
        public static string A_DnsZoneTransfert_Documentation {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A DNS Zone is configured with Zone Transfers enabled.
        /// </summary>
        public static string A_DnsZoneTransfert_Rationale {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_DnsZoneTransfert_ReportLocation {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to disable Zone Transfers.
        ///    Identify the faulty zone in the details below.
        ///    Go to the DNS console and select a zone in the &quot;Forward Lookup Zones&quot;.
        ///    Right click on it and switch to the &quot;Zone Transfers&quot; tab.
        ///    Then ensure &quot;Allow zone transfers&quot; is not enabled &quot;To any server&quot;.
        ///    You can also run: dnscmd /zoneresetsecondaries zone /noxfr
        ///    .
        /// </summary>
        public static string A_DnsZoneTransfert_Solution {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When the Zone Transfers mechanism is enabled, an attacker can retrieve all DNS records anonymously.
        ///    He can then use this feature to generate network noise to trigger a man in the middle attack and capture credentials.
        ///
        ///    This setting is domain wide, meaning that all servers share the same setting.
        ///    Please note that PingCastle does this check to only one DNS Server of the zone.
        ///
        ///    To test if the Zone Transfers is enabled, issue the following command:
        ///    on Linux: &lt;pre&gt;host -t axfr domain.n [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneTransfert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if DNS Zones are configured with Zone Transfers..
        /// </summary>
        public static string A_DnsZoneTransfert_Title {
            get {
                return ResourceManager.GetString("A_DnsZoneTransfert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Critical DNS zones (domain zone and RootDNSServers) are configured to accept anonymous updates, allowing any device to modify DNS records without authentication..
        /// </summary>
        public static string A_DnsZoneUpdate1_Description {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zone: {0} Domain: {1} DN: {2} Partition: {3}.
        /// </summary>
        public static string A_DnsZoneUpdate1_Detail {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/f97756c9-3783-428b-9451-b376f877319a
        ///    https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/dnscmd.
        /// </summary>
        public static string A_DnsZoneUpdate1_Documentation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Critical DNS zones allow anonymous updates.
        /// </summary>
        public static string A_DnsZoneUpdate1_Rationale {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_DnsZoneUpdate1_ReportLocation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To fix this vulnerability, configure the zone for secure-only updates:
        ///
        ///GUI Method:
        ///1. Open DNS Manager (dnsmgmt.msc)
        ///2. Navigate to the affected zone
        ///3. Right-click the zone → Properties → General tab
        ///4. Change &quot;Dynamic updates&quot; from &quot;Nonsecure and secure&quot; to &quot;Secure only&quot;
        ///
        ///PowerShell Method:
        ///&lt;code&gt;
        ///# Find all zones with insecure updates
        ///Get-DnsServerZone | Where-Object {$_.DynamicUpdate -eq &quot;NonsecureAndSecure&quot;}
        ///
        ///# Fix a specific zone
        ///Set-DnsServerPrimaryZone -Name &quot;contoso.com&quot; -DynamicUpda [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneUpdate1_Solution {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Active Directory-integrated DNS zones can be configured to accept three types of updates: no updates (static), secure updates only (authenticated), or nonsecure and secure updates. This rule examines your most critical DNS zones to determine if they allow nonsecure updates.
        ///
        ///The zones checked by this rule are the foundation of Active Directory operations: your primary domain DNS zone (e.g., contoso.com), the RootDNSServers zone, and _msdcs zones. The _msdcs zones are particularly critical as they contain  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneUpdate1_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Critical DNS zones allow anonymous updates.
        /// </summary>
        public static string A_DnsZoneUpdate1_Title {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate1_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DNS zones other than the primary domain zone are configured to accept anonymous updates, allowing any device to modify DNS records without authentication..
        /// </summary>
        public static string A_DnsZoneUpdate2_Description {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zone: {0} Domain: {1} DN: {2} Partition: {3}.
        /// </summary>
        public static string A_DnsZoneUpdate2_Detail {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/f97756c9-3783-428b-9451-b376f877319a
        ///    https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/dnscmd.
        /// </summary>
        public static string A_DnsZoneUpdate2_Documentation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Additional DNS zones allow anonymous updates.
        /// </summary>
        public static string A_DnsZoneUpdate2_Rationale {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_DnsZoneUpdate2_ReportLocation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To fix this vulnerability, configure all zones for secure-only updates:
        ///
        ///GUI Method:
        ///1. Open DNS Manager (dnsmgmt.msc)
        ///2. Navigate to the affected zone
        ///3. Right-click the zone → Properties → General tab
        ///4. Change &quot;Dynamic updates&quot; from &quot;Nonsecure and secure&quot; to &quot;Secure only&quot;
        ///
        ///PowerShell Method:
        ///&lt;code&gt;
        ///# Find all zones with insecure updates
        ///Get-DnsServerZone | Where-Object {$_.DynamicUpdate -eq &quot;NonsecureAndSecure&quot;}
        ///
        ///# Fix a specific zone
        ///Set-DnsServerPrimaryZone -Name &quot;10.0.0.in-addr.arpa&quot; -Dy [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneUpdate2_Solution {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Beyond the critical infrastructure zones checked by A-DnsZoneUpdate1, Active Directory typically hosts numerous additional DNS zones including reverse lookup zones (like 10.0.0.in-addr.arpa), application-specific zones, and subdomain zones. This rule examines all these secondary zones to identify those configured to accept nonsecure updates.
        ///
        ///While these zones might seem less critical than your domain and _msdcs zones, they still present significant security risks when configured for nonsecure updates. Re [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DnsZoneUpdate2_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Additional DNS zones allow anonymous updates.
        /// </summary>
        public static string A_DnsZoneUpdate2_Title {
            get {
                return ResourceManager.GetString("A_DnsZoneUpdate2_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains having the NSPI protocol exposed without any required account.
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_Description {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nspi/6dd0a3ea-b4d4-4a73-a857-add03a89a543.
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_Documentation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DsHeuristics has been set to allow anonymous access to the NSPI protocol.
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_Rationale {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The easiest and fastest way to correct this issue is to &lt;b&gt;replace the eighth (8th) character of the DsHeuristics attribute&lt;/b&gt;. If it is not a 0, replace by 0 to fix the issue..
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_Solution {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The way an Active Directory behaves can be controlled via the attribute &lt;i&gt;DsHeuristics&lt;/i&gt; of &lt;i&gt;CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration&lt;/i&gt;. A parameter stored in its attribute and whose value is &lt;i&gt;fAllowAnonNSPI&lt;/i&gt; can be set to allow access to the NSPI protocol without any account.
        ///The NSPI protocol is used internally by Exchange to resolve addresses, and thus can be used to dump all the users of the forest. It can be exposed to the internet via RPC over HTTP..
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for access without any account to the Name Service Provider Interface (NSPI) protocol.
        /// </summary>
        public static string A_DsHeuristicsAllowAnonNSPI_Title {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAllowAnonNSPI_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains having a forest setting which allows access to the domain without any account .
        /// </summary>
        public static string A_DsHeuristicsAnonymous_Description {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/anonymous-ldap-operations-active-directory-disabled.
        /// </summary>
        public static string A_DsHeuristicsAnonymous_Documentation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DsHeuristics has been set to allow anonymous sessions..
        /// </summary>
        public static string A_DsHeuristicsAnonymous_Rationale {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The easiest and fastest way to correct this issue is to &lt;b&gt;replace the seventh (7th) character of the DsHeuristics attribute&lt;/b&gt;. If it is a 2, replace by 0 to fix the issue..
        /// </summary>
        public static string A_DsHeuristicsAnonymous_Solution {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The way an Active Directory behaves can be controlled via the attribute &lt;i&gt;DsHeuristics&lt;/i&gt; of &lt;i&gt;CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration&lt;/i&gt;. A parameter stored in its attribute and whose value is &lt;i&gt;fLDAPBlockAnonOps&lt;/i&gt; can be set to allow access without any account on the &lt;b&gt;whole forest level&lt;/b&gt;.
        ///It is possible to verify the results provided by the PingCastle solution by using a Kali Linux distribution. You should run &lt;i&gt;rpcclient -U &apos;&apos; -N target_ip_address&lt;/i&gt; to finally type [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DsHeuristicsAnonymous_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for access without any account via a forest wide setting.
        /// </summary>
        public static string A_DsHeuristicsAnonymous_Title {
            get {
                return ResourceManager.GetString("A_DsHeuristicsAnonymous_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains having the SPN and UPN uniqueness check disabled.
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_Description {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5
        ///https://support.microsoft.com/en-us/topic/kb5008382-verification-of-uniqueness-for-user-principal-name-service-principal-name-and-the-service-principal-name-alias-cve-2021-42282-4651b175-290c-4e59-8fcb-e4e5cd0cdb29.
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_Documentation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DsHeuristics has been set to disable the UPN or SPN uniqueness check.
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_Rationale {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks changes to the DsHeuristics attribute, ensuring the UPN/SPN uniqueness check remains enforced to prevent security misconfigurations and mitigate risks..
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_RelevantProducts {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The easiest and fastest way to correct this issue is to &lt;b&gt;replace the 21th character of the DsHeuristics attribute&lt;/b&gt;. If it is not a 0, replace by 0 to fix the issue..
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_Solution {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The way an Active Directory behaves can be controlled via the attribute &lt;i&gt;DsHeuristics&lt;/i&gt; of &lt;i&gt;CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration&lt;/i&gt;. A parameter stored in its attribute and whose value is &lt;i&gt;DoNotVerifyUPNAndOrSPNUniqueness&lt;/i&gt; can be set to disable the UPN or SPN check.
        ///This setting has been introduced to overwrite the mitigation of the vulnerability CVE-2021-42282 fixed by the KB5008382..
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the UPN and SPN uniqueness check has been disabled.
        /// </summary>
        public static string A_DsHeuristicsDoNotVerifyUniqueness_Title {
            get {
                return ResourceManager.GetString("A_DsHeuristicsDoNotVerifyUniqueness_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains having mitigation for CVE-2021-42291 not set to enabled.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Description {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Setting: {0} Position: {1} Value: {2}.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Detail {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5
        ///https://support.microsoft.com/en-au/topic/kb5008383-active-directory-permissions-updates-cve-2021-42291-536d5555-ffba-4248-a60e-d6cbc849cde1.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Documentation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DsHeuristics has not been set to enable the mitigation for CVE-2021-42291.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Rationale {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks changes to the DsHeuristics attribute, preventing security misconfigurations and mitigating risks such as CVE-2021-42282..
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_RelevantProducts {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The easiest and fastest way to correct this issue is to &lt;b&gt;replace the 28th and 29th character of the DsHeuristics attribute&lt;/b&gt;.
        ///    The value of LDAPAddAutZVerifications and LDAPOwnerModify should be set to 1.
        ///    
        ///    Open the procedure embedded into the KB5008383 to apply this mitigation and change the DsHeuristics value.
        ///    
        ///    Note: You have to pay attention that there are control characters at the 10th and 20th position to avoid undesired changes of the DsHeuristics attribute.
        ///    Typically i [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Solution {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The way an Active Directory behaves can be controlled via the attribute &lt;i&gt;DsHeuristics&lt;/i&gt; of &lt;i&gt;CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration&lt;/i&gt;.
        ///    A parameter stored in its attribute and whose value is &lt;i&gt;LDAPAddAutZVerifications&lt;/i&gt; and &lt;i&gt;LDAPOwnerModify&lt;/i&gt; can be set to modify the mitigatation of CVE-2021-42291.
        ///The KB5008383 has introduced changes to default security descriptor of Computer containers to add audit and limit computer creation without being admin.
        ///Indeed, it is  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the mitigation for CVE-2021-42291 has been enabled.
        /// </summary>
        public static string A_DsHeuristicsLDAPSecurity_Title {
            get {
                return ResourceManager.GetString("A_DsHeuristicsLDAPSecurity_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the Guest account of the domain is not enabled.
        /// </summary>
        public static string A_Guest_Description {
            get {
                return ResourceManager.GetString("A_Guest_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_Guest_Documentation {
            get {
                return ResourceManager.GetString("A_Guest_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Guest account of the domain is enabled.
        /// </summary>
        public static string A_Guest_Rationale {
            get {
                return ResourceManager.GetString("A_Guest_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Auditor| monitors the usage of guest accounts and alerts on suspicious activity, enabling prompt detection and response..
        /// </summary>
        public static string A_Guest_RelevantProducts {
            get {
                return ResourceManager.GetString("A_Guest_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_Guest_ReportLocation {
            get {
                return ResourceManager.GetString("A_Guest_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to find the Guest account and disable it..
        /// </summary>
        public static string A_Guest_Solution {
            get {
                return ResourceManager.GetString("A_Guest_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Guest account is a special account whose SID is S-1-5-domain-501. It is used as a non-nominative account to allow anyone to connect to the Active Directory.
        ///Unless there is a justification about its activation, this represents a security issue because anybody can use this account to connect to any computer without any trace..
        /// </summary>
        public static string A_Guest_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_Guest_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the guest account is enabled.
        /// </summary>
        public static string A_Guest_Title {
            get {
                return ResourceManager.GetString("A_Guest_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no weakness related to hardened paths.
        /// </summary>
        public static string A_HardenedPaths_Description {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}  Key: {1} RequireIntegrity: {2} RequireMutualAuthentication: {3} RequirePrivacy: {4}.
        /// </summary>
        public static string A_HardenedPaths_Detail {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://labs.withsecure.com/publications/how-to-own-any-windows-network-with-group-policy-hijacking-attacks
        ///https://talubu.wordpress.com/2018/02/28/configuring-unc-hardened-access-through-group-policy/
        ///https://adsecurity.org/?p=1405
        ///https://support.microsoft.com/en-us/topic/ms15-011-vulnerability-in-group-policy-could-allow-remote-code-execution-february-10-2015-91b4bda2-945d-455b-ebbb-01d1ec191328.
        /// </summary>
        public static string A_HardenedPaths_Documentation {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hardened Paths have been modified to lower the security level.
        /// </summary>
        public static string A_HardenedPaths_Rationale {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally  blocks unauthorized changes to Group Policy Objects (GPOs), helping protect against domain takeover attacks. .
        /// </summary>
        public static string A_HardenedPaths_RelevantProducts {
            get {
                return ResourceManager.GetString("A_HardenedPaths_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#HardenedPaths&quot;&gt;Hardened Paths configuration&lt;/a&gt; section..
        /// </summary>
        public static string A_HardenedPaths_ReportLocation {
            get {
                return ResourceManager.GetString("A_HardenedPaths_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to edit the Hardened Path section in the GPO.
        ///    This section is located in Computer Configuration/Policies/Administrative Templates/Network/Network Provider.
        ///  Check each value reported here and make sure that entries containing SYSVOL or NETLOGON have RequireIntegrity and RequireMutualAuthentication set to 1.
        ///  In addition to that, check entries having the pattern \\DCName\* and apply the same solution..
        /// </summary>
        public static string A_HardenedPaths_Solution {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Two vulnerabilities have been reported in 2015 (MS15-011 and MS15-014) which allows a domain takeover via GPO modifications done with a man-in-the-middle attack.
        ///    To mitigate these vulnerabilites, Microsoft has designed a workaround named &quot;Hardened Paths&quot;. It forces connection settings to enforce Integrity, Mutual Authentication or Privacy.
        ///    By default if this policy is empty, if will enforce Integrity and Mutual Authentication on the SYSVOL or NETLOGON shares.
        ///    This rule checks if there have be [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_HardenedPaths_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_HardenedPaths_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hardened Paths weakness.
        /// </summary>
        public static string A_HardenedPaths_Title {
            get {
                return ResourceManager.GetString("A_HardenedPaths_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to alert when the password for the krbtgt account can be used to compromise the whole domain. This password can be used to sign every Kerberos ticket. Monitoring it closely often mitigates the risk of golden ticket attacks greatly..
        /// </summary>
        public static string A_Krbtgt_Description {
            get {
                return ResourceManager.GetString("A_Krbtgt_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/faqs-from-the-field-on-krbtgt-reset/ba-p/2367838
        ///https://github.com/microsoft/New-KrbtgtKeys.ps1
        ///https://github.com/PSSecTools/Krbtgt.
        /// </summary>
        public static string A_Krbtgt_Documentation {
            get {
                return ResourceManager.GetString("A_Krbtgt_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last change of the Kerberos password: {count} day(s) ago.
        /// </summary>
        public static string A_Krbtgt_Rationale {
            get {
                return ResourceManager.GetString("A_Krbtgt_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| detects and responds to identity-based attacks, including Golden Ticket and others..
        /// </summary>
        public static string A_Krbtgt_RelevantProducts {
            get {
                return ResourceManager.GetString("A_Krbtgt_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#krbtgt&quot;&gt;Krbtgt&lt;/a&gt;.
        /// </summary>
        public static string A_Krbtgt_ReportLocation {
            get {
                return ResourceManager.GetString("A_Krbtgt_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The password of the krbtgt account should be changed twice to invalidate the golden ticket attack.
        ///&lt;b&gt;Beware: two changes of the krbtgt password not replicated to domain controllers can break these domain controllers&lt;/b&gt; You should wait at least 10 hours between each krbtgt password change (this is the duration of a ticket life).
        ///
        ///There are several possibilities to change the krbtgt password.
        ///First, a &lt;a href=&quot;https://github.com/microsoft/New-KrbtgtKeys.ps1/blob/master/New-KrbtgtKeys.ps1&quot;&gt;Microsoft scri [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_Krbtgt_Solution {
            get {
                return ResourceManager.GetString("A_Krbtgt_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos is an authentication protocol. It is using a secret, stored as the password of the krbtgt account, to sign its tickets. If the hash of the password of the krbtgt account is retrieved, it can be used to generate authentication tickets at will.
        ///To mitigate this attack, it is recommended to change the krbtgt password between 40 days and 6 months. If this is not the case, every backup done until the last password change of the krbtgt account can be used to emit Golden tickets, compromising the entire  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_Krbtgt_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_Krbtgt_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mitigate golden ticket attack via a regular change of the krbtgt password.
        /// </summary>
        public static string A_Krbtgt_Title {
            get {
                return ResourceManager.GetString("A_Krbtgt_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose of this rule is to ensure that there is no LAPS permission problems with computers that have been added manually to the domain by a user.
        /// </summary>
        public static string A_LAPS_Joined_Computers_Description {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_LAPS_Joined_Computers_Detail {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.securityinsider-wavestone.com/2020/01/taking-over-windows-workstations-pxe-laps.html.
        /// </summary>
        public static string A_LAPS_Joined_Computers_Documentation {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The local admin password of at least one computer can be retrieved by the user who joined the computer to the domain.
        /// </summary>
        public static string A_LAPS_Joined_Computers_Rationale {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#laps&quot;&gt;LAPS&lt;/a&gt;.
        /// </summary>
        public static string A_LAPS_Joined_Computers_ReportLocation {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review the security of the computer objects listed in the LAPS section below to change their ownership (you can give it to the domain admins group).
        ///    Check if the creator has also write permissions to change the owner or the security descriptor and if he has the right &quot;all extended rights&quot; on this object.
        ///    If it is the case, remove the permissions granted to this user.
        ///    .
        /// </summary>
        public static string A_LAPS_Joined_Computers_Solution {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, every domain user can add up to 10 computers to the domain (see the rule S-ADRegistration for more information).
        ///    When a computer is added to the domain, the owner of the computer object is the user who joined the computer.
        ///    To trace this insertion, a special attribute mS-DS-CreatorSID is added, whose value is the SID of its creator.
        ///    When LAPS is installed, the local admin account has its password stored in a special attribute named, by default, ms-mcs-AdmPwd. Its access is retricte [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_LAPS_Joined_Computers_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if LAPS passwords can be retrieved from computers that have been added manually by users..
        /// </summary>
        public static string A_LAPS_Joined_Computers_Title {
            get {
                return ResourceManager.GetString("A_LAPS_Joined_Computers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to make sure that there is a proper password policy in place for the native local administrator account..
        /// </summary>
        public static string A_LAPS_Not_Installed_Description {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.microsoft.com/en-us/download/details.aspx?id=46899.
        /// </summary>
        public static string A_LAPS_Not_Installed_Documentation {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LAPS doesn&apos;t seem to be installed.
        /// </summary>
        public static string A_LAPS_Not_Installed_Rationale {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#laps&quot;&gt;LAPS&lt;/a&gt;.
        /// </summary>
        public static string A_LAPS_Not_Installed_ReportLocation {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If you don&apos;t have any provisioning process or password solution to manage local administrators, you should install the LAPS solution. If you address the risk through alternative measures, you can disregard this finding. Customers using Netwrix PingCastle Pro or Enterprise versions can add this item as an exception..
        /// </summary>
        public static string A_LAPS_Not_Installed_Solution {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LAPS (Local Administrator Password Solution) is the advised solution to handle passwords for the native local administrator account on all workstations, as it is a simple way to handle most of the subject..
        /// </summary>
        public static string A_LAPS_Not_Installed_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the LAPS tool to handle the native local administrator passwords is installed.
        /// </summary>
        public static string A_LAPS_Not_Installed_Title {
            get {
                return ResourceManager.GetString("A_LAPS_Not_Installed_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check that the integrity of the network protocol LDAP as not been endangered by explicitly disabling LDAP signing..
        /// </summary>
        public static string A_LDAPSigningDisabled_Description {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_LDAPSigningDisabled_Detail {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-ldap-client-signing-requirements.
        /// </summary>
        public static string A_LDAPSigningDisabled_Documentation {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one GPO disables explicitly LDAP client signature.
        /// </summary>
        public static string A_LDAPSigningDisabled_Rationale {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks unauthorized changes to Group Policy Objects (GPOs), ensuring LDAP signing requirements remain enforced to protect against man-in-the-middle attacks..
        /// </summary>
        public static string A_LDAPSigningDisabled_RelevantProducts {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_LDAPSigningDisabled_ReportLocation {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the GPO specified in Details and change the setting in &quot;Network security: LDAP client signing requirements&quot;.
        ///    Disable this setting, or set it to &quot;Negotiate signing&quot; or &quot;Require Signature&quot;.
        ///The setting is located in :
        ///    Computer configuration -&gt; Policies -&gt; Windows Settings -&gt;Security Settings -&gt; Local Policies -&gt; Security Options.
        ///As an alternative, the file GptTmpl.inf can be manually edited..
        /// </summary>
        public static string A_LDAPSigningDisabled_Solution {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The LDAP signature feature enables the integrity of the network communication between the computer and the domain controller.
        ///Hackers aim at intercepting the communication at the network layer and modify the network dialog to grant themselves admin privileges.
        ///The goal of this feature is to defeat these attacks.
        ///Unfortunately, not all devices support LDAP signature. That&apos;s why the best practice is to Require Signature if possible or to, at least, try to negotiate it.
        ///In this case, the LDAP signature fea [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_LDAPSigningDisabled_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure LDAP signing requirements is not set to None.
        /// </summary>
        public static string A_LDAPSigningDisabled_Title {
            get {
                return ResourceManager.GetString("A_LDAPSigningDisabled_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify if accounts without password are allowed to be accessed from the network. This represents a high risk, as an account without a password is essentially an account that cannot be assigned to anyone. .
        /// </summary>
        public static string A_LimitBlankPasswordUse_Description {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_LimitBlankPasswordUse_Detail {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj852174(v=ws.11).
        /// </summary>
        public static string A_LimitBlankPasswordUse_Documentation {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one policy has been found where the account having an empty password can be accessed from the network [{count}].
        /// </summary>
        public static string A_LimitBlankPasswordUse_Rationale {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| detects and optionally blocks GPO changes, preventing unauthorized configuration drift and securing your Active Directory environment..
        /// </summary>
        public static string A_LimitBlankPasswordUse_RelevantProducts {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_LimitBlankPasswordUse_ReportLocation {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the policy having the setting &quot;Limit local account use of blank passwords to console logon only&quot; disabled and enabled the setting..
        /// </summary>
        public static string A_LimitBlankPasswordUse_Solution {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies if there is a GPO with the setting &quot;Limit local account use of blank passwords to console logon only&quot; disabled..
        /// </summary>
        public static string A_LimitBlankPasswordUse_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for GPO allowing accounts without password to be accessed from the network.
        /// </summary>
        public static string A_LimitBlankPasswordUse_Title {
            get {
                return ResourceManager.GetString("A_LimitBlankPasswordUse_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The authentication protocol NTLM v1 can use the LM password hash algorithm which is very weak if enabled by a GPO..
        /// </summary>
        public static string A_LMHashAuthorized_Description {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Setting: {1}.
        /// </summary>
        public static string A_LMHashAuthorized_Detail {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_LMHashAuthorized_Documentation {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one policy has been found where the very weak LM hash algorithm can be used [{count}].
        /// </summary>
        public static string A_LMHashAuthorized_Rationale {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_LMHashAuthorized_ReportLocation {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A GPO explicitly disabled the default security policy LmCompatibilityLevel or NoLMHash. Using the information provided, identify the setting modified in the GPO and fix it.
        ///All security settings should be modified in the Domain GPO Editor and are located in Computer Configuration / Policies / Windows Settings / Security Settings / Local Policies / Security Options
        ///For NoLMHash the setting is located in: Network security: Do not store LAN Manager hash value on next password change
        ///For LmCompatibilityLevel [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_LMHashAuthorized_Solution {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LM hash, or LAN Manager hash is a hash algorithm developed by Microsoft since Windows 3.1. Due to a flawed design, hashes retrieved from the network can be reverted to the clear text password in a matter of seconds..
        /// </summary>
        public static string A_LMHashAuthorized_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for GPO enabling the unsafe algorithm LM hash.
        /// </summary>
        public static string A_LMHashAuthorized_Title {
            get {
                return ResourceManager.GetString("A_LMHashAuthorized_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the deprecated MD2 hashing algorithm in Intermediate Certificate.
        /// </summary>
        public static string A_MD2IntermediateCert_Description {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD2IntermediateCert_Detail {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.ssi.gouv.fr/archive/fr/sciences/fichiers/lcr/mu04c.pdf.
        /// </summary>
        public static string A_MD2IntermediateCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted INTERMEDIATE certificate found has a MD2 signature [{count}].
        /// </summary>
        public static string A_MD2IntermediateCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD2IntermediateCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD2IntermediateCert_Solution {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD2 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_MD2IntermediateCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Intermediate Certificates using unsafe hashing algorithm (MD2).
        /// </summary>
        public static string A_MD2IntermediateCert_Title {
            get {
                return ResourceManager.GetString("A_MD2IntermediateCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no Root Certificates use the deprecated MD2 hashing algorithm.
        /// </summary>
        public static string A_MD2RootCert_Description {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD2RootCert_Detail {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.ssi.gouv.fr/archive/fr/sciences/fichiers/lcr/mu04c.pdf.
        /// </summary>
        public static string A_MD2RootCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted ROOT certificate found has a MD2 signature [{count}].
        /// </summary>
        public static string A_MD2RootCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD2RootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD2RootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD2RootCert_Solution {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD2 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time. Nevertheless, the root certificate algorithm has no direct impact on the security, but it can be used indirectly to force the use of this algorithm in the issued certificate.
        /// </summary>
        public static string A_MD2RootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD2RootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Root Certificates using unsafe hashing algorithm (MD2).
        /// </summary>
        public static string A_MD2RootCert_Title {
            get {
                return ResourceManager.GetString("A_MD2RootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the deprecated MD4 hashing algorithm in Intermediate Certificate.
        /// </summary>
        public static string A_MD4IntermediateCert_Description {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD4IntermediateCert_Detail {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6150.
        /// </summary>
        public static string A_MD4IntermediateCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted INTERMEDIATE certificate found has a MD4 signature [{count}].
        /// </summary>
        public static string A_MD4IntermediateCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD4IntermediateCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD4IntermediateCert_Solution {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD4 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_MD4IntermediateCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Intermediate Certificates using unsafe hashing algorithm (MD4).
        /// </summary>
        public static string A_MD4IntermediateCert_Title {
            get {
                return ResourceManager.GetString("A_MD4IntermediateCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no Root Certificates use the deprecated MD4 hashing algorithm.
        /// </summary>
        public static string A_MD4RootCert_Description {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD4RootCert_Detail {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6150.
        /// </summary>
        public static string A_MD4RootCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted ROOT certificate found has a MD4 signature [{count}].
        /// </summary>
        public static string A_MD4RootCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD4RootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD4RootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD4RootCert_Solution {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD4 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time. Nevertheless, the root certificate algorithm has no direct impact on the security, but it can be used indirectly to force the use of this algorithm in the issued certificate.
        /// </summary>
        public static string A_MD4RootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD4RootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Root Certificates using unsafe hashing algorithm (MD4).
        /// </summary>
        public static string A_MD4RootCert_Title {
            get {
                return ResourceManager.GetString("A_MD4RootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the deprecated MD5 hashing algorithm in Intermediate Certificate.
        /// </summary>
        public static string A_MD5IntermediateCert_Description {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD5IntermediateCert_Detail {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.kb.cert.org/vuls/id/836068.
        /// </summary>
        public static string A_MD5IntermediateCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted INTERMEDIATE certificate found has a MD5 signature [{count}].
        /// </summary>
        public static string A_MD5IntermediateCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD5IntermediateCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD5IntermediateCert_Solution {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD5 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_MD5IntermediateCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Intermediate Certificates using unsafe hashing algorithm (MD5).
        /// </summary>
        public static string A_MD5IntermediateCert_Title {
            get {
                return ResourceManager.GetString("A_MD5IntermediateCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no Root Certificates use the deprecated MD5 hashing algorithm.
        /// </summary>
        public static string A_MD5RootCert_Description {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_MD5RootCert_Detail {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.kb.cert.org/vuls/id/836068.
        /// </summary>
        public static string A_MD5RootCert_Documentation {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted ROOT certificate found has a MD5 signature [{count}].
        /// </summary>
        public static string A_MD5RootCert_Rationale {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_MD5RootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_MD5RootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_MD5RootCert_Solution {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD5 hashing algorithm is not considered safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time. Nevertheless, the root certificate algorithm has no direct impact on the security, but it can be used indirectly to force the use of this algorithm in the issued certificate.
        /// </summary>
        public static string A_MD5RootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MD5RootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Root Certificates using unsafe hashing algorithm (MD5).
        /// </summary>
        public static string A_MD5RootCert_Title {
            get {
                return ResourceManager.GetString("A_MD5RootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify if there are local groups such as local administrators, terminal server access, where Authenticated Users or Everyone is being granted access by a GPO.
        /// </summary>
        public static string A_MembershipEveryone_Description {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} MemberOf: {1} User: {2}.
        /// </summary>
        public static string A_MembershipEveryone_Detail {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/technet-wiki/20402.active-directory-group-policy-restricted-groups.
        /// </summary>
        public static string A_MembershipEveryone_Documentation {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of local group where anybody is a member granted by GPO: {count}.
        /// </summary>
        public static string A_MembershipEveryone_Rationale {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks unauthorized GPO changes, ensuring a secure environment..
        /// </summary>
        public static string A_MembershipEveryone_RelevantProducts {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to correct the issue, you should edit the GPO and change the local group assignation. Another solution is to change the group to a more targeted one containing a limited set of users..
        /// </summary>
        public static string A_MembershipEveryone_Solution {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is possible that a GPO adds local membership using a GPO.
        ///    In this case the rule triggers if one is found with &quot;Everyone&quot; or &quot;Authenticated Users&quot; or &quot;Domain Users&quot;, ... as members.
        ///    It basically means that the local Group has no restriction on belongs to it. This represents a security risk as Local Group are supposed to have more accesses or rights.
        ///    The GPO configuration is located in Computer Configuration / Policies / Windows Settings / Security Settings / Restricted Group
        ///    
        ///    This [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_MembershipEveryone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if a GPO assigns everyone to a local group.
        /// </summary>
        public static string A_MembershipEveryone_Title {
            get {
                return ResourceManager.GetString("A_MembershipEveryone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if the password policy of the domain enforces users to have at least 8 characters in their password.
        /// </summary>
        public static string A_MinPwdLen_Description {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_MinPwdLen_Detail {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.microsoft.com/en-us/research/publication/password-guidance/.
        /// </summary>
        public static string A_MinPwdLen_Documentation {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Policy where the password length is less than 8 characters: {count}.
        /// </summary>
        public static string A_MinPwdLen_Rationale {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#passwordpolicies&quot;&gt;Password policies&lt;/a&gt;.
        /// </summary>
        public static string A_MinPwdLen_ReportLocation {
            get {
                return ResourceManager.GetString("A_MinPwdLen_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the issue, the best way is to either remove the GPO enabling short password, or to modify it in order to increase the password length to at least 8 characters.
        /// </summary>
        public static string A_MinPwdLen_Solution {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A check is performed to identify if the GPO regarding password policy allows less than 8 characters password. Short passwords represent a high risk because they can fairly easily be brute-forced or password sprayed. Most CERT and agencies advise for at least 8 characters (and often this number goes up to 12).
        /// </summary>
        public static string A_MinPwdLen_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_MinPwdLen_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for short password length in password policy.
        /// </summary>
        public static string A_MinPwdLen_Title {
            get {
                return ResourceManager.GetString("A_MinPwdLen_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that local name resolution protocol (LLMNR) cannot be used to collect credentials by performing a network attack.
        /// </summary>
        public static string A_NoGPOLLMNR_Description {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_NoGPOLLMNR_Detail {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://youtu.be/Fg2gvk0qgjM.
        /// </summary>
        public static string A_NoGPOLLMNR_Documentation {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No GPO has been found which disables LLMNR or at least one GPO does enable it explicitly.
        /// </summary>
        public static string A_NoGPOLLMNR_Rationale {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_NoGPOLLMNR_ReportLocation {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enable the GPO &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/client-management/mdm/policy-csp-admx-dnsclient#admx-dnsclient-turn-off-multicast&quot;&gt;Turn off multicast name resolution&lt;/a&gt; and check that no GPO overrides this setting.
        ///    (if it is the case, the policy involved will be displayed below).
        /// </summary>
        public static string A_NoGPOLLMNR_Solution {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LLMNR is a protocol which translates names such as foo.bar.com into an ip address. LLMNR has been designed to translate name locally in case the default protocol DNS is not available.
        ///    Regarding Active Directory, DNS is mandatory which makes LLMNR useless.
        ///  LLMNR exploits typo mistakes or faster response time to redirect users to a specially designed share, server or website.
        ///  Being trusted, this service will trigger the single sign on procedure which can be abused to retrieve the user credentials.        /// [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_NoGPOLLMNR_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if LLMNR can be used to steal credentials.
        /// </summary>
        public static string A_NoGPOLLMNR_Title {
            get {
                return ResourceManager.GetString("A_NoGPOLLMNR_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that mitigations are in place against the Bloodhound tool.
        /// </summary>
        public static string A_NoNetSessionHardening_Description {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_NoNetSessionHardening_Detail {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/p0w3rsh3ll/NetCease
        ///https://adsecurity.org/?p=3299.
        /// </summary>
        public static string A_NoNetSessionHardening_Documentation {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No GPO has been found which implements NetCease.
        /// </summary>
        public static string A_NoNetSessionHardening_Rationale {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_NoNetSessionHardening_ReportLocation {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If this mitigation is not part of the computer image, apply the following recommendations:
        ///Run the NetCease PowerShell script (referenced below) on a reference workstation.
        ///Open the Group Policy Management Console. Right-click the Group Policy object (GPO) that should contain the new preference item, and then click Edit .
        ///In the console tree under Computer Configuration, expand the Preferences folder, and then expand the Windows Settings folder.
        ///Right-click the Registry node, point to New, and select Re [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_NoNetSessionHardening_Solution {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, Windows computers allow any authenticated user to enumerate network sessions to it.
        ///This means an attacker could enumerate network sessions to a file share hosting home directories or a Domain Controller to see who&apos;s connected to SYSVOL (to apply Group Policy) and determine which workstations each user and admin account is logged into.
        ///Bloodhound uses this capability extensively to map out credentials in the network.
        ///
        ///Disabling Net Session Enumeration removes the capability for any user to e [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_NoNetSessionHardening_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if NetCease has been put in place to mitigate Bloodhound.
        /// </summary>
        public static string A_NoNetSessionHardening_Title {
            get {
                return ResourceManager.GetString("A_NoNetSessionHardening_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to give information regarding a best practice for the Service Account password policy. Indeed, having a 20+ characters password for this account greatly helps reducing the risk of Kerberoasting attacks (offline cracking of the TGS tickets)
        ///Note: PSO (Password Settings Objects) will be visible only if the user, which collected the information, has the permission to view it..
        /// </summary>
        public static string A_NoServicePolicy_Description {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_NoServicePolicy_Detail {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.microsoft.com/en-us/research/publication/password-guidance/.
        /// </summary>
        public static string A_NoServicePolicy_Documentation {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No password policy for service accounts found (MinimumPasswordLength&gt;=20).
        /// </summary>
        public static string A_NoServicePolicy_Rationale {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#passwordpolicies&quot;&gt;Password Policies&lt;/a&gt;.
        /// </summary>
        public static string A_NoServicePolicy_ReportLocation {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to  The recommended way to handle service accounts is to use &quot;Managed service accounts&quot; introduced since Windows Server 2008 R2 (search for &quot;msDS-ManagedServiceAccount&quot;).
        ///To solve the anomaly, you should implement a PSO or GPO password guarantying a 20+ length password..
        /// </summary>
        public static string A_NoServicePolicy_Solution {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The rule is purely informative, as it gives insights regarding a best practice. It verifies if there is a GPO or PSO enforcing a 20+ characters password for the Service Accounts. .
        /// </summary>
        public static string A_NoServicePolicy_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the Password Policy for Service Accounts (Information).
        /// </summary>
        public static string A_NoServicePolicy_Title {
            get {
                return ResourceManager.GetString("A_NoServicePolicy_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure the failure of one domain controller will not stop the domain..
        /// </summary>
        public static string A_NotEnoughDC_Description {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/administration/performance-tuning/role/active-directory-server/capacity-planning-for-active-directory-domain-services.
        /// </summary>
        public static string A_NotEnoughDC_Documentation {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The number of DCs is too small to provide redundancy: {count} DC.
        /// </summary>
        public static string A_NotEnoughDC_Rationale {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Recovery for Active Directory| helps ensure business continuity by quickly restoring domain controller in case of a failure, minimizing downtime..
        /// </summary>
        public static string A_NotEnoughDC_RelevantProducts {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_NotEnoughDC_ReportLocation {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Increase the number of domain controllers by installing new ones..
        /// </summary>
        public static string A_NotEnoughDC_Solution {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A single domain controller failure can lead to a lack of availability of the domain if the number of servers is too low. To have a minimum redundancy, the number of DC should be at least 2. For Labs, this rule can be ignored, and you can add this rule into the exception list..
        /// </summary>
        public static string A_NotEnoughDC_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that there are enough DCs to provide basic redundancy.
        /// </summary>
        public static string A_NotEnoughDC_Title {
            get {
                return ResourceManager.GetString("A_NotEnoughDC_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the old NTFRS protocol is not used to replicate the SYSVOL share..
        /// </summary>
        public static string A_NTFRSOnSysvol_Description {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_NTFRSOnSysvol_Detail {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/storage/dfs-replication/migrate-sysvol-to-dfsr
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/recovering-missing-frs-objects-attributes-ad
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-frs1/d18cc589-677e-4133-97e5-113641792c5e
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/sysvol-dfsr-migration-fails-after-in-place-upgrade.
        /// </summary>
        public static string A_NTFRSOnSysvol_Documentation {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The old protocol NTFRS is used to replicate the SYSVOL share.
        /// </summary>
        public static string A_NTFRSOnSysvol_Rationale {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_NTFRSOnSysvol_ReportLocation {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to migrate from NTFRS to DFS replication. See the documentation below for more details.
        ///    .
        /// </summary>
        public static string A_NTFRSOnSysvol_Solution {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NTFRS is an old protocol and is considered insecure.
        ///    The SYSVOL share is mainly hosted on domain controllers to host GPO files and login scripts.
        ///  If the content can be modified, it can be used to grant to a hacker the control of the computers reading these configuration files.
        ///To know if the setting is enabled, PingCastle read the following LDAP entry: CN=Domain System Volume (SYSVOL share),CN=File Replication Service,CN=System
        ///If there is any entry found, the program consider that NTFRS is in use [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_NTFRSOnSysvol_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if NTFRS is used to replicate SYSVOL.
        /// </summary>
        public static string A_NTFRSOnSysvol_Title {
            get {
                return ResourceManager.GetString("A_NTFRSOnSysvol_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if access without any account, aka NULL Sessions, is possible within the Active Directory. A NULL Session is a session opened anonymously to access the AD, often used by attackers to perform a recon operation on the AD, to identify weaknesses.
        /// </summary>
        public static string A_NullSession_Description {
            get {
                return ResourceManager.GetString("A_NullSession_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_NullSession_Detail {
            get {
                return ResourceManager.GetString("A_NullSession_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.sans.org/reading-room/whitepapers/windows/null-sessions-nt-2000-286.
        /// </summary>
        public static string A_NullSession_Documentation {
            get {
                return ResourceManager.GetString("A_NullSession_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC(s) with NULL SESSION enabled: {count}.
        /// </summary>
        public static string A_NullSession_Rationale {
            get {
                return ResourceManager.GetString("A_NullSession_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt; and  &lt;a href=&quot;#nullsession&quot;&gt;Null Session&lt;/a&gt;.
        /// </summary>
        public static string A_NullSession_ReportLocation {
            get {
                return ResourceManager.GetString("A_NullSession_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate other PingCastle rules such as A-PreWin2000Anonymous or A-DsHeuristicsAnonymous which triggered and apply the solutions. You can use the PingCastle scanner mode to do a manual check and prove the extraction of the data..
        /// </summary>
        public static string A_NullSession_Solution {
            get {
                return ResourceManager.GetString("A_NullSession_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unlike other rules, which check for known cause of anonymous access, this rule tries to enumerate accounts from the domain without any account. The program uses two methods: MS-SAMR with a NULL connection and MS-LSAT, which forces SID resolution with a well known SID.
        ///NULL sessions are deactivated by default since Windows Server 2003 and Windows XP. For compatibility reasons a setting enabling them may be still active years after.
        ///It is possible to verify the results provided by the PingCastle solution by [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_NullSession_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_NullSession_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Retrieve data from the domain without any account.
        /// </summary>
        public static string A_NullSession_Title {
            get {
                return ResourceManager.GetString("A_NullSession_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to identify domains which allow access without any account because of a Pre-Windows 2000 compatibility.
        /// </summary>
        public static string A_PreWin2000Anonymous_Description {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/7a76a403-ed8d-4c39-adb7-a3255cab82c5.
        /// </summary>
        public static string A_PreWin2000Anonymous_Documentation {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The group Everyone and/or Anonymous is present in the Pre-Windows 2000 group..
        /// </summary>
        public static string A_PreWin2000Anonymous_Rationale {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the &quot;Everyone&quot; and &quot;Anonymous&quot; from the PreWin2000 group while making sure that the group &quot;Authenticated Users&quot; is present, then reboot each DC.
        ///    Note: removing the group &quot;Authenticated Users&quot; (and not keep it like advised here) is an advanced recommendation quoted in the rule A-PreWin2000AuthenticatedUsers.
        /// </summary>
        public static string A_PreWin2000Anonymous_Solution {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a Windows Server 2003 DC is promoted, a pre-Windows 2000 compatibility setting can be enabled through the wizard. If it is enabled, the wizard will add &quot;Everyone&quot; and &quot;Anonymous&quot; to the pre-Windows 2000 compatible access group, and by doing so, it will authorize the domain to be queried without an account (null session)
        ///It is possible to verify the results provided by the PingCastle solution by using a Kali distribution. You should run [rpcclient -U &apos;&apos; -N target_ip_address] to finally type [enumdomuse [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_PreWin2000Anonymous_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Windows 2000 compatibility which allows access to the domain without any account.
        /// </summary>
        public static string A_PreWin2000Anonymous_Title {
            get {
                return ResourceManager.GetString("A_PreWin2000Anonymous_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is checking if the &quot;Pre-Windows 2000 Compatible Access&quot; group contains &quot;Authenticated Users&quot;.
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_Description {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/7a76a403-ed8d-4c39-adb7-a3255cab82c5
        ///https://www.gradenegger.eu/?p=1132.
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_Documentation {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The PreWin2000 compatible group contains &quot;Authenticated Users&quot;.
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_Rationale {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove &quot;Authenticated Users&quot; from the PreWin2000 group..
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_Solution {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The pre-Windows 2000 compatible access group grants access to some RPC calls.
        ///    Its default and secure value is the &quot;Authenticated Users&quot; group which allows users to perform group look-up using legacy protocols.
        ///    
        ///  If this group contains &quot;Authenticated Users&quot;, it increases the impact of the exploitation of vulnerabilities in legacy protocols such as the Print Spooler service.
        ///    Indeed, in the #PrintNightmare attack, it enables a patch bypass on domain controllers because the property Elevated To [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check that the &quot;Pre-Windows 2000 Compatible Access&quot; group does not contain &quot;Authenticated Users&quot;.
        /// </summary>
        public static string A_PreWin2000AuthenticatedUsers_Title {
            get {
                return ResourceManager.GetString("A_PreWin2000AuthenticatedUsers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is checking that no additional account has been added to the &quot;Pre-Windows 2000 Compatible Access&quot; group.
        /// </summary>
        public static string A_PreWin2000Other_Description {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string A_PreWin2000Other_Detail {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/7a76a403-ed8d-4c39-adb7-a3255cab82c5.
        /// </summary>
        public static string A_PreWin2000Other_Documentation {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one user, computer or group has been added as a member to the PreWin2000 compatible group.
        /// </summary>
        public static string A_PreWin2000Other_Rationale {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the members from the PreWin2000 group while making sure that the group &quot;Authenticated Users&quot; is present. Then reboot each DC..
        /// </summary>
        public static string A_PreWin2000Other_Solution {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The pre-Windows 2000 compatible access group grants access to some RPC calls which should not be available to users or computers..
        /// </summary>
        public static string A_PreWin2000Other_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check that the &quot;Pre-Windows 2000 Compatible Access&quot; group has not been modified from its default.
        /// </summary>
        public static string A_PreWin2000Other_Title {
            get {
                return ResourceManager.GetString("A_PreWin2000Other_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the schema has been updated for the creation of the Protected Users group..
        /// </summary>
        public static string A_ProtectedUsers_Description {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/protected-users-security-group.
        /// </summary>
        public static string A_ProtectedUsers_Documentation {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Protected Users group doesn&apos;t exist on the domain..
        /// </summary>
        public static string A_ProtectedUsers_Rationale {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Management| provides comprehensive control, management, and attestation for Active Directory groups, ensuring secure and accurate group configurations.\r\n Netwrix Threat Manager| monitors and optionally blocks changes to the Protected Users group, preventing unauthorized modifications and strengthening authentication security. .
        /// </summary>
        public static string A_ProtectedUsers_RelevantProducts {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The schema version is indicated in &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt;.
        /// </summary>
        public static string A_ProtectedUsers_ReportLocation {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Protected Users group is automatically created when the PDC (primary DC) emulator role is transferred to Windows Server 2012 R2 or newer domain controller. The group is then automatically replicated to all other domain controllers.
        ///&lt;b&gt; Warning: Do not add service accounts into this group as this will result in &quot;authentication failure&quot; messages. Use &quot;protected accounts&quot; instead&lt;/b&gt;.
        /// </summary>
        public static string A_ProtectedUsers_Solution {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Protected Users group is a special group, which is a very effective mitigation solution to counter attacks using credential theft starting with Windows 8.1. Older Operating System must be updated to use this protection, such as the &lt;b&gt;Windows 7 KB2871997&lt;/b&gt; patch..
        /// </summary>
        public static string A_ProtectedUsers_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for presence of the Protected Users group.
        /// </summary>
        public static string A_ProtectedUsers_Title {
            get {
                return ResourceManager.GetString("A_ProtectedUsers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to alert when a password is present in a GPO. If a password is in a GPO, the password should be considered compromised and reset..
        /// </summary>
        public static string A_PwdGPO_Description {
            get {
                return ResourceManager.GetString("A_PwdGPO_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} login: {1} password: {2}.
        /// </summary>
        public static string A_PwdGPO_Detail {
            get {
                return ResourceManager.GetString("A_PwdGPO_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be.
        /// </summary>
        public static string A_PwdGPO_Documentation {
            get {
                return ResourceManager.GetString("A_PwdGPO_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of password(s) found in GPO: {count}.
        /// </summary>
        public static string A_PwdGPO_Rationale {
            get {
                return ResourceManager.GetString("A_PwdGPO_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and alerts on suspicious GPO modifications, helping detect unauthorized changes that could expose credentials or lead to domain compromise..
        /// </summary>
        public static string A_PwdGPO_RelevantProducts {
            get {
                return ResourceManager.GetString("A_PwdGPO_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#gpoobfuscatedpassword&quot;&gt;Obfuscated Passwords&lt;/a&gt;.
        /// </summary>
        public static string A_PwdGPO_ReportLocation {
            get {
                return ResourceManager.GetString("A_PwdGPO_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve this issue, you should manually change the password to a new one. If this password is shared on many systems, each system should have a different password. If the GPO was used to define the native local administrator account, it is recommended to install a password solution manager such as LAPS..
        /// </summary>
        public static string A_PwdGPO_Solution {
            get {
                return ResourceManager.GetString("A_PwdGPO_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PingCastle attempts to identify passwords stored in GPOs. If PingCastle was able to retrieve a password, attackers can also obtain it and so the account should be considered compromised. Note that Microsoft published the AES key used to encrypt passwords in GPOs, which is why even an encrypted password is insecure..
        /// </summary>
        public static string A_PwdGPO_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_PwdGPO_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Find Password GPO.
        /// </summary>
        public static string A_PwdGPO_Title {
            get {
                return ResourceManager.GetString("A_PwdGPO_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if a GPO alters the password policy of the domain to enable reversible passwords.
        /// </summary>
        public static string A_ReversiblePwd_Description {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string A_ReversiblePwd_Detail {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption.
        /// </summary>
        public static string A_ReversiblePwd_Documentation {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one policy has been found where the reversible encryption has been enabled [{count}].
        /// </summary>
        public static string A_ReversiblePwd_Rationale {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string A_ReversiblePwd_ReportLocation {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to remove the reversible passwords, we advise to identify the GPO indicated by the program and change the setting &quot;Store passwords using reversible encryption&quot;.
        /// </summary>
        public static string A_ReversiblePwd_Solution {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The policy &quot;Store passwords using reversible encryption&quot; is enabled. In this case, it means that the password is actually stored in clear text in the &lt;i&gt;supplementalCredential&lt;/i&gt; attribute of the account and that it can be retrieved using a DCSync attack..
        /// </summary>
        public static string A_ReversiblePwd_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for GPO which enables reversible passwords.
        /// </summary>
        public static string A_ReversiblePwd_Title {
            get {
                return ResourceManager.GetString("A_ReversiblePwd_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that Anonymous Binding on RootDse is not enabled.
        /// </summary>
        public static string A_RootDseAnonBinding_Description {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/3f0137a1-63df-400c-bf97-e1040f055a99
        ///    https://blog.lithnet.io/2018/12/disabling-unauthenticated-binds-in.html.
        /// </summary>
        public static string A_RootDseAnonBinding_Documentation {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Anonymous Binding to the rootDse is enabled.
        /// </summary>
        public static string A_RootDseAnonBinding_Rationale {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the attribute msDS-Other-Settings of the object CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration.
        ///    Add a new line with the content: DenyUnauthenticatedBind=1
        ///    .
        /// </summary>
        public static string A_RootDseAnonBinding_Solution {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The rootDse is a special object that enables clients to discover the functionalities of the server, such as LDAP version or support for special processing.
        ///    On Windows, it can be accessed by default without binding, which allows everyone to access this data.
        ///    There is no confidential data in this attribute, only the Operating System version and the name of the domain.
        ///    Since Windows 2019, the rootDse access can be set to require authentication.
        ///    You can test the anonymous access of the rootD [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_RootDseAnonBinding_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the rootDse Anonymous Binding is disabled.
        /// </summary>
        public static string A_RootDseAnonBinding_Title {
            get {
                return ResourceManager.GetString("A_RootDseAnonBinding_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the deprecated SHA0 hashing algorithm in Intermediate Certificate.
        /// </summary>
        public static string A_SHA0IntermediateCert_Description {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_SHA0IntermediateCert_Detail {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6194.
        /// </summary>
        public static string A_SHA0IntermediateCert_Documentation {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted INTERMEDIATE certificate found has a SHA0 signature [{count}].
        /// </summary>
        public static string A_SHA0IntermediateCert_Rationale {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_SHA0IntermediateCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_SHA0IntermediateCert_Solution {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SHA0 hashing algorithm is not considered as safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_SHA0IntermediateCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Intermediate Certificates using unsafe hashing algorithm (SHA0).
        /// </summary>
        public static string A_SHA0IntermediateCert_Title {
            get {
                return ResourceManager.GetString("A_SHA0IntermediateCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no Root Certificates use the deprecated SHA-0 hashing algorithm.
        /// </summary>
        public static string A_SHA0RootCert_Description {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_SHA0RootCert_Detail {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6194.
        /// </summary>
        public static string A_SHA0RootCert_Documentation {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted ROOT certificate found has a SHA0 signature [{count}].
        /// </summary>
        public static string A_SHA0RootCert_Rationale {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_SHA0RootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_SHA0RootCert_Solution {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SHA0 hashing algorithm is not considered as safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_SHA0RootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Root Certificates using unsafe hashing algorithm (SHA0).
        /// </summary>
        public static string A_SHA0RootCert_Title {
            get {
                return ResourceManager.GetString("A_SHA0RootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the deprecated SHA1 hashing algorithm in Intermediate Certificate.
        /// </summary>
        public static string A_SHA1IntermediateCert_Description {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_SHA1IntermediateCert_Detail {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6194.
        /// </summary>
        public static string A_SHA1IntermediateCert_Documentation {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted INTERMEDIATE certificate found has a SHA1 signature [{count}].
        /// </summary>
        public static string A_SHA1IntermediateCert_Rationale {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_SHA1IntermediateCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_SHA1IntermediateCert_Solution {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SHA1 hashing algorithm is not considered as safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_SHA1IntermediateCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Intermediate Certificates using unsafe hashing algorithm (SHA1).
        /// </summary>
        public static string A_SHA1IntermediateCert_Title {
            get {
                return ResourceManager.GetString("A_SHA1IntermediateCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no Root Certificates use the deprecated SHA-1 hashing algorithm.
        /// </summary>
        public static string A_SHA1RootCert_Description {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Subject: {1}.
        /// </summary>
        public static string A_SHA1RootCert_Detail {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://tools.ietf.org/html/rfc6194.
        /// </summary>
        public static string A_SHA1RootCert_Documentation {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted ROOT certificate found has a SHA1 signature [{count}].
        /// </summary>
        public static string A_SHA1RootCert_Rationale {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_SHA1RootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_SHA1RootCert_Solution {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SHA1 hashing algorithm is not considered as safe. There are design flaws inherent to the algorithm that allow an attacker to generate a hash collision in less than a brute-force time.
        /// </summary>
        public static string A_SHA1RootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Root Certificates using unsafe hashing algorithm (SHA1).
        /// </summary>
        public static string A_SHA1RootCert_Title {
            get {
                return ResourceManager.GetString("A_SHA1RootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that automatic password rotation for smart card only accounts is in place.
        /// </summary>
        public static string A_SmartCardPwdRotation_Description {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-US/lifecycle/products/windows-server-2012-r2.
        /// </summary>
        public static string A_SmartCardPwdRotation_Documentation {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to msDS-ExpirePasswordsOnSmartCardOnlyAccounts is not set.
        /// </summary>
        public static string A_SmartCardPwdRotation_Rationale {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string A_SmartCardPwdRotation_ReportLocation {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure your domain&apos;s functional level is at least Windows Server 2016 or higher.
        ///    Set the msDS-ExpirePasswordsOnSmartCardOnlyAccounts attribute to TRUE at the domain root.
        ///    This action will enable the automatic rotation of the password hash for smart card only accounts. .
        /// </summary>
        public static string A_SmartCardPwdRotation_Solution {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to With the introduction of a feature in Windows Server 2016, the password hash for accounts that require smart card authentication can be automatically rotated.
        ///    This is important because when smart card authentication is used, the password itself is not utilized, leading to the password hash remaining unchanged.
        ///    An unchanged password hash over an extended period increases the risk of being brute-forced.
        ///    .
        /// </summary>
        public static string A_SmartCardPwdRotation_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Automatic password rotation for smart card is not in place.
        /// </summary>
        public static string A_SmartCardPwdRotation_Title {
            get {
                return ResourceManager.GetString("A_SmartCardPwdRotation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to make sure the requirement of Smart Cards doesn&apos;t degrade password rotation.
        /// </summary>
        public static string A_SmartCardRequired_Description {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/blogs/positivesecurity/smartcard-and-pass-the-hash
        ///https://github.com/nsacyber/Pass-the-Hash-Guidance.
        /// </summary>
        public static string A_SmartCardRequired_Documentation {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of account(s) using a smart card whose password is not changed: {count}.
        /// </summary>
        public static string A_SmartCardRequired_Rationale {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#smartcardmandatorywithnopasswordchange&quot;&gt;Smart Card and Password&lt;/a&gt;.
        /// </summary>
        public static string A_SmartCardRequired_ReportLocation {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to There are a few solutions to fix this issue, the most obvious being to change the user password on a regular basis. 
        ///    The fastest way is to check if the domain has the attribute &lt;i&gt;msDS-ExpirePasswordsOnSmartCardOnlyAccounts&lt;/i&gt;, which is available for Windows Server 2016 and later versions and handles periodically hash change. 
        ///    Be sure also that functional level is at least Windows Server 2016 the GPO &quot;Enable rolling of expiring NTLM secrets during sign on, for users who are required to use Micros [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_SmartCardRequired_Solution {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using smart cards to protected sensitive accounts is a good thing. Nevertheless, when the &quot;Smart Card required&quot; flag is set, the password of the account is not changed anymore by default. The rule is triggered 90 days after the last change of the attribute unicodePwd. This value is collected using the replication metadata of the attribute 589914.
        /// </summary>
        public static string A_SmartCardRequired_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for accounts using smart card with unchanged password for a long time.
        /// </summary>
        public static string A_SmartCardRequired_Title {
            get {
                return ResourceManager.GetString("A_SmartCardRequired_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the SMB version 2 protocol has signing enabled when communicating with domain controllers.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Description {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Detail {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.sentinelone.com/labs/relaying-potatoes-another-unexpected-privilege-escalation-vulnerability-in-windows-rpc-protocol/
        ///https://trustedsec.com/blog/a-comprehensive-guide-on-relaying-anno-2022
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/36172e53-ac81-48fb-b2e3-caa3761b9157.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Documentation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} Domain Controller(s) have been found, where SMB signing is not enabled.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Rationale {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_ReportLocation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enable the group policy &quot;Digitally sign communications (if client agrees)&quot; or check for any policy, which may alter the server settings. See the &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/smbv1-microsoft-network-server-digitally-sign-communications-if-client-agrees&quot;&gt;official documentation&lt;/a&gt; for more information..
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Solution {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If SMB signing is not required on domain controllers, it can lead to several security risks and potential problems like Man-in-the-Middle (MitM) or relaying attacks like e.g. the so called RemotePotato0. An often used attack tool is Python Responder, which can be used to compromise a domain by listening for SMB connections, injecting rogue data into the communications and relaying it to a different system.
        ///SMB v1 does not provide a mechanism to enforce integrity and thus is compromised easily. SMB v2 (and  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the file share protocol can sign its network dialog.
        /// </summary>
        public static string A_SMB2SignatureNotEnabled_Title {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotEnabled_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the SMB version 2 protocol has signing enforced when communicating with domain controllers.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Description {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Detail {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.sentinelone.com/labs/relaying-potatoes-another-unexpected-privilege-escalation-vulnerability-in-windows-rpc-protocol/
        ///https://trustedsec.com/blog/a-comprehensive-guide-on-relaying-anno-2022
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/36172e53-ac81-48fb-b2e3-caa3761b9157.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Documentation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} Domain Controller(s) have been found where SMB signing is not enforced.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Rationale {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_ReportLocation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enable the group policy &quot;Digitally sign communications (always)&quot; or check for any policy which may alter the server settings. See the &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/microsoft-network-server-digitally-sign-communications-always&quot;&gt;official documentation&lt;/a&gt; for more information..
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Solution {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If SMB signing is not required on domain controllers, it can lead to several security risks and potential problems like Man-in-the-Middle (MitM) or relaying attacks like e.g. the so called RemotePotato0. An often used attack tool is Python Responder, which can be used to compromise a domain by listening for SMB connections, injecting rogue data into the communications and relaying it to a different system.
        ///SMB v1 does not provide a mechanism to enforce integrity and thus is compromised easily. SMB v2 (and  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the file share protocol requires its client to sign its network dialog.
        /// </summary>
        public static string A_SMB2SignatureNotRequired_Title {
            get {
                return ResourceManager.GetString("A_SMB2SignatureNotRequired_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if password information may be stored in AD attributes.
        /// </summary>
        public static string A_UnixPwd_Description {
            get {
                return ResourceManager.GetString("A_UnixPwd_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User: {0}.
        /// </summary>
        public static string A_UnixPwd_Detail {
            get {
                return ResourceManager.GetString("A_UnixPwd_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/f3adda9f-89e1-4340-a3f2-1f0a6249f1f8
        ///https://www.blackhillsinfosec.com/domain-goodness-learned-love-ad-explorer/.
        /// </summary>
        public static string A_UnixPwd_Documentation {
            get {
                return ResourceManager.GetString("A_UnixPwd_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one user has an attribute set which is known to potentially contain a password.
        /// </summary>
        public static string A_UnixPwd_Rationale {
            get {
                return ResourceManager.GetString("A_UnixPwd_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#unixpasswordsfound&quot;&gt;Unix Passwords&lt;/a&gt;.
        /// </summary>
        public static string A_UnixPwd_ReportLocation {
            get {
                return ResourceManager.GetString("A_UnixPwd_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The attributes unixUserPassword and userPassword from the mentioned user accounts should be cleared, unless the remote system is known to have a strong cryptographic protocol..
        /// </summary>
        public static string A_UnixPwd_Solution {
            get {
                return ResourceManager.GetString("A_UnixPwd_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To perform Single Sign On (SSO) systems need to share secrets with Active Directory.
        ///    This is not the case for all systems such as Unix and Mainframe and designers have found a workaround by storing this secret into a user account attribute.
        ///  However not all systems did implement a proper and cryptographically safe protocol and they are checking the password submitted in their system with an AD attribute.
        ///At that time, it was not known that these attributes can be queried by everyone and as consequen [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_UnixPwd_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_UnixPwd_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if attributes unixUserPassword and userPassword are set.
        /// </summary>
        public static string A_UnixPwd_Title {
            get {
                return ResourceManager.GetString("A_UnixPwd_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of a certificate using a weak RSA key.
        /// </summary>
        public static string A_WeakRSARootCert_Description {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Source: {0} Subject: {1} Module: {2} Expires: {3}.
        /// </summary>
        public static string A_WeakRSARootCert_Detail {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.iad.gov/iad/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/commercial-national-security-algorithm-suite-factsheet.cfm
        ///    https://www.ssi.gouv.fr/guide/cryptographie-les-regles-du-rgs/.
        /// </summary>
        public static string A_WeakRSARootCert_Documentation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted certificate found has a weak RSA key [{count}].
        /// </summary>
        public static string A_WeakRSARootCert_Rationale {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_WeakRSARootCert_ReportLocation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued..
        /// </summary>
        public static string A_WeakRSARootCert_Solution {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A RSA key certificate with a modulus under 1024 bits is considered unsafe.
        /// </summary>
        public static string A_WeakRSARootCert_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for certificates using a weak signing algorithm (RSA under 1024 bits).
        /// </summary>
        public static string A_WeakRSARootCert_Title {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of a certificate using a relatively weak RSA key.
        /// </summary>
        public static string A_WeakRSARootCert2_Description {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Source: {0} Subject: {1} Module: {2} Expires: {3}.
        /// </summary>
        public static string A_WeakRSARootCert2_Detail {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.iad.gov/iad/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/commercial-national-security-algorithm-suite-factsheet.cfm
        ///    https://www.ssi.gouv.fr/guide/cryptographie-les-regles-du-rgs/.
        /// </summary>
        public static string A_WeakRSARootCert2_Documentation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trusted certificate found has a relatively weak RSA key [{count}].
        /// </summary>
        public static string A_WeakRSARootCert2_Rationale {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#certificates&quot;&gt;Certificates&lt;/a&gt;.
        /// </summary>
        public static string A_WeakRSARootCert2_ReportLocation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the matter, the certificate should be removed from the GPO and if needed, certificates depending on it should be reissued.
        ///    
        ///    Please note that this rule is the companion of the rule A-WeakRSARootCert which checks for unsecured certificates (key lower than 1024 bits)..
        /// </summary>
        public static string A_WeakRSARootCert2_Solution {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A RSA key certificate with a modulus under 1024 bits is considered as not safe. This is checked by the rule A-WeakRSARootCert.
        ///    This rule checks for certificates having a key under 2048 bits which is considered as having a lower level of security and under 3072 bits for certificates valid after 2030..
        /// </summary>
        public static string A_WeakRSARootCert2_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Certificates using a relatively weak signing algorithm (RSA between 1024 bits and 2048 or expires after 2030).
        /// </summary>
        public static string A_WeakRSARootCert2_Title {
            get {
                return ResourceManager.GetString("A_WeakRSARootCert2_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all WSUS servers don&apos;t use weak SSL protocols..
        /// </summary>
        public static string A_WSUS_SslProtocol_Description {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to WSUS: {0} Protocol: {1}.
        /// </summary>
        public static string A_WSUS_SslProtocol_Detail {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/technet-wiki/2249.windows-server-20082008r2-how-to-disable-sslv2-on-domain-controller-dsforum2wiki
        ///https://learn.microsoft.com/en-us/dotnet/framework/network-programming/tls#configuring-schannel-protocols-in-the-windows-registry
        ///https://adsecurity.org/?p=376.
        /// </summary>
        public static string A_WSUS_SslProtocol_Documentation {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one WSUS server uses a weak SSL protocol..
        /// </summary>
        public static string A_WSUS_SslProtocol_Rationale {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#WSUSsettings&quot;&gt;WSUS settings&lt;/a&gt; section..
        /// </summary>
        public static string A_WSUS_SslProtocol_ReportLocation {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Apply Windows updates and registry tweaks described in the documentation section to disable the weak SSL protocols.
        ///  .
        /// </summary>
        public static string A_WSUS_SslProtocol_Solution {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SSL version 2 and SSL version 3 are considered weak and it is strongly advised to disable them.
        ///    The SSL protocols in Windows is provided by the Schannel component.
        ///The Schannel component needs to be tuned in order to not propose these weak protocols. Many guidelines to handle this problem issued by Microsoft do not talk about Schannel but rather IIS. These guidlines are quoted in the documentation section below.
        ///
        ///PingCastle is able to check the SSL version if SSL is exposed.
        ///Please note that PingCa [rest of string was truncated]&quot;;.
        /// </summary>
        public static string A_WSUS_SslProtocol_TechnicalExplanation {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if WSUS is used with weak SSL protocol..
        /// </summary>
        public static string A_WSUS_SslProtocol_Title {
            get {
                return ResourceManager.GetString("A_WSUS_SslProtocol_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members of administrators&apos; groups are a priority target. By misconfiguring their protection, the password of the account can be retrieved by an attacker, or it can leverage internal mechanisms of the AD such as authentication to act on its behalf..
        /// </summary>
        public static string AccountTakeOver_Detail {
            get {
                return ResourceManager.GetString("AccountTakeOver_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delegation is used to perform day to day activities. It is important to control it..
        /// </summary>
        public static string ACLCheck_Detail {
            get {
                return ResourceManager.GetString("ACLCheck_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is important to know how much administrators are in place and to track the use of emergency accounts.
        /// </summary>
        public static string AdminControl_Detail {
            get {
                return ResourceManager.GetString("AdminControl_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The default audit policy of Windows does not collect key events to trace activities or discover past compromise..
        /// </summary>
        public static string Audit_Detail {
            get {
                return ResourceManager.GetString("Audit_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Although Active Directory has been designed for redundancy, a backup process is key for a recovery plan..
        /// </summary>
        public static string Backup_Detail {
            get {
                return ResourceManager.GetString("Backup_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certificates are an alternative to passwords. Their protection is crucial to avoid any backdoor..
        /// </summary>
        public static string CertificateTakeOver_Detail {
            get {
                return ResourceManager.GetString("CertificateTakeOver_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Permissions granted to someone can be difficult to analyze. Hackers use this fact to chain multiple permission leaks in order to gain control of the domain..
        /// </summary>
        public static string ControlPath_Detail {
            get {
                return ResourceManager.GetString("ControlPath_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delegations are very complex to understand and may grant more privileges than initially thought..
        /// </summary>
        public static string DelegationCheck_Detail {
            get {
                return ResourceManager.GetString("DelegationCheck_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to There are key secrets in Active Directory which provide seeds to the cryptographic processes. A leak could lead to a total compromise of the domain..
        /// </summary>
        public static string GoldenTicket_Detail {
            get {
                return ResourceManager.GetString("GoldenTicket_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By reusing existing objects, whose credentials may be the same among all objects or stored on configuration files or in memory, a third party can take them over..
        /// </summary>
        public static string InactiveUserOrComputer_Detail {
            get {
                return ResourceManager.GetString("InactiveUserOrComputer_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Most of the changes can be reversed. Some not, and it can break the domain..
        /// </summary>
        public static string IrreversibleChange_Detail {
            get {
                return ResourceManager.GetString("IrreversibleChange_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The GPO deployed settings are applied to computers locally and they can be abused to take control of individual computers..
        /// </summary>
        public static string LocalGroupVulnerability_Detail {
            get {
                return ResourceManager.GetString("LocalGroupVulnerability_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Network attacks such as interception or modification can be used to run commands on behalf an administrator..
        /// </summary>
        public static string NetworkSniffing_Detail {
            get {
                return ResourceManager.GetString("NetworkSniffing_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is important to have a database of all the assets and control the physical security of the server. If one server is compromised physically, all the secrets of the domain can be exposed..
        /// </summary>
        public static string NetworkTopography_Detail {
            get {
                return ResourceManager.GetString("NetworkTopography_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By abusing a misconfiguration, an attacker can gain the control of the domain..
        /// </summary>
        public static string ObjectConfig_Detail {
            get {
                return ResourceManager.GetString("ObjectConfig_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operating systems have a life-cycle where its manufacturer provides patches. If the operating system is not supported anymore, vulnerabilities are not fixed anymore..
        /// </summary>
        public static string ObsoleteOS_Detail {
            get {
                return ResourceManager.GetString("ObsoleteOS_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cryptography and computer power have evolved during the time and the oldest protocols do not provide the same level of security anymore. They can be broken and used to gain control of the domain..
        /// </summary>
        public static string OldAuthenticationProtocols_Detail {
            get {
                return ResourceManager.GetString("OldAuthenticationProtocols_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NT4 like trusts do not provide an accurate level of security and by the use of its old protocols, put the domain at risk..
        /// </summary>
        public static string OldTrustProtocol_Detail {
            get {
                return ResourceManager.GetString("OldTrustProtocol_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure proper isolation of administrative activities and to prevent any admin from having an email address configured in the domain..
        /// </summary>
        public static string P_AdminEmailOn_Description {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account: {0} Email: {1}.
        /// </summary>
        public static string P_AdminEmailOn_Detail {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/securing-privileged-access-for-the-ad-admin-part-1/ba-p/259166.
        /// </summary>
        public static string P_AdminEmailOn_Documentation {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of admin account with an email address defined: {count}.
        /// </summary>
        public static string P_AdminEmailOn_Rationale {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| helps automate account creation while enforcing policies to exclude specific attributes, such as email enablement, ensuring compliance and reducing the risk of misconfiguration. \r\nNetwrix Threat Manager| monitors and optionally blocks changes to admin account properties, to detect potential misconfigurations or abuse and ensure security and compliance..
        /// </summary>
        public static string P_AdminEmailOn_RelevantProducts {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_AdminEmailOn_ReportLocation {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that administrators do not use the privileged account for browsing the internet or receiving emails.
        ///    We highly recommend that you implement this practice to lower the risk of an admin compromise.
        ///    
        ///      To remove this alert, you have to edit the properties of the user account and clear the email attribute.
        ///      Keep in mind that this action will silence the alert, but the risk may still be present.
        ///  .
        /// </summary>
        public static string P_AdminEmailOn_Solution {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The recommended approach for secure administration is to implement a Tier Zero model.
        ///    In this model, low privileged actions cannot be made by highly privileged accounts such as admins.
        ///    This means that, in practice, administrators should have two separate Windows accounts: one for regular activities and one for performing privileged actions.
        ///    .
        /// </summary>
        public static string P_AdminEmailOn_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if administrator accounts are email enabled..
        /// </summary>
        public static string P_AdminEmailOn_Title {
            get {
                return ResourceManager.GetString("P_AdminEmailOn_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if the Native Administrator account is used..
        /// </summary>
        public static string P_AdminLogin_Description {
            get {
                return ResourceManager.GetString("P_AdminLogin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC: {0} LoginTime: {1}.
        /// </summary>
        public static string P_AdminLogin_Detail {
            get {
                return ResourceManager.GetString("P_AdminLogin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models
        ///https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/how-lastlogontimestamp-is-updated-with-kerberos-s4u2self/ba-p/257135.
        /// </summary>
        public static string P_AdminLogin_Documentation {
            get {
                return ResourceManager.GetString("P_AdminLogin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The native administrator account has been used recently: {count} day(s) ago.
        /// </summary>
        public static string P_AdminLogin_Rationale {
            get {
                return ResourceManager.GetString("P_AdminLogin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To mitigate security risks effectively, it is advisable to reserve the Native Administrator account solely for emergency situations, with daily tasks being carried out using separate accounts. It is strongly recommended not to employ this account routinely, opting instead for individualized accounts for administrators and dedicated accounts for services. It&apos;s worth noting that any anomalies related to this practice will be automatically addressed and resolved within 35 days following the last login by a nat [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_AdminLogin_Solution {
            get {
                return ResourceManager.GetString("P_AdminLogin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Native Administrator account serves as the primary administrative account and often shares its password with the Directory Services Restore Mode password. This shared password presents a potential security vulnerability as it can be exploited to gain control of the domain, even if the account itself is disabled. This vulnerability is particularly notable in the context of a DCSync attack.
        ///
        ///Previously, the last login date was obtained by querying the LastLogonTimestamp LDAP attribute from the Active Di [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_AdminLogin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_AdminLogin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Native administrator usage.
        /// </summary>
        public static string P_AdminLogin_Title {
            get {
                return ResourceManager.GetString("P_AdminLogin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if the number of administrator accounts is not disproportionate. Very few users should have domain admin accounts..
        /// </summary>
        public static string P_AdminNum_Description {
            get {
                return ResourceManager.GetString("P_AdminNum_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models.
        /// </summary>
        public static string P_AdminNum_Documentation {
            get {
                return ResourceManager.GetString("P_AdminNum_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Users in Admins groups = {count} (more than 50 or than 10% of all active users).
        /// </summary>
        public static string P_AdminNum_Rationale {
            get {
                return ResourceManager.GetString("P_AdminNum_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| can alert on changes to privileged groups and optionally block unauthorized additions to prevent privilege escalation..
        /// </summary>
        public static string P_AdminNum_RelevantProducts {
            get {
                return ResourceManager.GetString("P_AdminNum_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_AdminNum_ReportLocation {
            get {
                return ResourceManager.GetString("P_AdminNum_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is strongly advised to perform a review of which users have domain administrator rights, and to ensure that these rights are actually needed. Indeed, the end goal is to remove as much domain administrator as possible, as very few users actually need these high-level rights.
        ///    The rule is triggered if the number of cumulated privileged members is more than 50 accounts or if it represents more than 10 percent of the user accounts.
        ///  This rule is enabled only if the domain has more than 100 active users [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_AdminNum_Solution {
            get {
                return ResourceManager.GetString("P_AdminNum_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Every domain administrator represents a possible security breach, this is why it is strongly advised to have as few domain administrator accounts as possible.
        /// </summary>
        public static string P_AdminNum_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_AdminNum_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for number of Administrator accounts above the baseline.
        /// </summary>
        public static string P_AdminNum_Title {
            get {
                return ResourceManager.GetString("P_AdminNum_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all admins are changing their passwords at least every 3 years.
        /// </summary>
        public static string P_AdminPwdTooOld_Description {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account: {0} Creation: {1} LastChanged: {2}.
        /// </summary>
        public static string P_AdminPwdTooOld_Detail {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_AdminPwdTooOld_Documentation {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of admin with a password older than 3 years: {count}.
        /// </summary>
        public static string P_AdminPwdTooOld_Rationale {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| enables administrators to remove direct administrative permissions from Active Directory and enforce least privilege principles, ensuring secure and efficient AD management.\r\nNetwrix Password Policy Enforcer| prevents the use of known breached passwords and enforces strong password policies, enhancing security for Active Directory accounts.\r\nNetwrix Privilege Secure| helps organizations manage privileged access to admin accounts through password rotation, removal of standing p [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_AdminPwdTooOld_RelevantProducts {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_AdminPwdTooOld_ReportLocation {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to We advised to read the ANSSI guidelines about this, which is quoted in the documentation section below.
        ///    .
        /// </summary>
        public static string P_AdminPwdTooOld_Solution {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule ensure that passwords of administrator are well managed..
        /// </summary>
        public static string P_AdminPwdTooOld_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all admin passwords are changed on the field..
        /// </summary>
        public static string P_AdminPwdTooOld_Title {
            get {
                return ResourceManager.GetString("P_AdminPwdTooOld_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no control path involving everyone..
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Description {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Group: {0}.
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Detail {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/BloodHoundAD/BloodHound
        ///https://github.com/ANSSI-FR/AD-control-paths.
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Documentation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Everyone can take control of a key domain object by abusing targeted permissions..
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Rationale {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| shifts direct Active Directory permissions to fine-grained, controlled management within Netwrix Directory Manager, ensuring least privilege assignments for enhanced security, while also enabling self-service password resets to reduce the need for tier 1 helpdesk involvement.\r\nNetwrix Access Analyzer| ensures admin privileges are not overprovisioned and removes unnecessary everyone-like groups along known control paths to minimize security risks..
        /// </summary>
        public static string P_ControlPathIndirectEveryone_RelevantProducts {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#controlpath&quot;&gt;Control Paths Analysis&lt;/a&gt;.
        /// </summary>
        public static string P_ControlPathIndirectEveryone_ReportLocation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should analyze the chart and determine which underlying object is involved and grants write permissions to everyone.
        ///    Then edit the permissions and locate the write permission involved.
        ///    Then delete it or replace it according to your delegation model..
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Solution {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      If you have access to a key server and the helpdesk can reset your password, then the helpdesk has access to the key server.
        ///This is the kind of logic used by hackers to take control of the domain using key infrastructure objects (domain root, ...) or groups (domain administrators, ...).
        ///Permissions are collected and analyzed to produce a control paths analysis.
        ///Only write permissions (and specific ones) are used for this analysis.
        ///Then the program identifies which users or computers, that are n [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_ControlPathIndirectEveryone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is a control path involving everyone-like groups..
        /// </summary>
        public static string P_ControlPathIndirectEveryone_Title {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectEveryone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if users can abuse their write access to obtain additional privileges..
        /// </summary>
        public static string P_ControlPathIndirectMany_Description {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Group: {0} Number: {1}.
        /// </summary>
        public static string P_ControlPathIndirectMany_Detail {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/BloodHoundAD/BloodHound
        ///https://github.com/ANSSI-FR/AD-control-paths.
        /// </summary>
        public static string P_ControlPathIndirectMany_Documentation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A large number of users or computers can take control of a key domain object by abusing targeted permissions..
        /// </summary>
        public static string P_ControlPathIndirectMany_Rationale {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| shifts direct Active Directory permissions to fine-grained, controlled management within Netwrix Directory Manager, enforcing least privilege assignments for enhanced security, while also enabling self-service password resets to reduce reliance on tier 1 helpdesk associates.\r\nNetwrix Access Analyzer| helps prevent admin privilege overprovisioning and streamlines bulk removal of unnecessary write permissions on known control paths to minimize security risks..
        /// </summary>
        public static string P_ControlPathIndirectMany_RelevantProducts {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#controlpath&quot;&gt;Control Paths Analysis&lt;/a&gt;.
        /// </summary>
        public static string P_ControlPathIndirectMany_ReportLocation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should analyze the chart and determine which underlying object is involved and grants too much write permissions.
        ///    Then edit the permissions and locate the write permission involved.
        ///    Then delete it or replace it according to your delegation model..
        /// </summary>
        public static string P_ControlPathIndirectMany_Solution {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      If you have access to a key server and the helpdesk can reset your password, then the helpdesk has access to the key server.
        ///This is the kind of logic used by hackers to take control of the domain using key infrastructure objects (domain root, ...) or groups (domain administrators, ...).
        ///Permissions are collected and analyzed to produce a control paths analysis.
        ///Only write permissions (and specific ones) are used for this analysis.
        ///Then the program identifies which users or computers, that are n [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_ControlPathIndirectMany_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is a control path involving too many users or computers..
        /// </summary>
        public static string P_ControlPathIndirectMany_Title {
            get {
                return ResourceManager.GetString("P_ControlPathIndirectMany_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify the presence of dangerous rights when a part of the domain is delegated to a third party.
        /// </summary>
        public static string P_DangerousExtendedRight_Description {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Account: {1} Right: {2}.
        /// </summary>
        public static string P_DangerousExtendedRight_Detail {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/tn-archive/ff405676(v=msdn.10).
        /// </summary>
        public static string P_DangerousExtendedRight_Documentation {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of dangerous extended right in delegation: {count}.
        /// </summary>
        public static string P_DangerousExtendedRight_Rationale {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_DangerousExtendedRight_ReportLocation {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unless there is a strong justification of their presence, these delegations should be removed. In addition, if the origin of this delegation cannot be found, their creation should be investigated as it could be related to a compromise of the domain.
        /// </summary>
        public static string P_DangerousExtendedRight_Solution {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The right &quot;REANIMATE_TOMBSTONE&quot; used to undelete objects, &quot;UNEXPIRE_PASSWORD&quot; used to undo the expiration of a password, or &quot;SID_HISTORY&quot; used to create an alternate identity is considered dangerous. Indeed, this right can be used to trigger a backdoor..
        /// </summary>
        public static string P_DangerousExtendedRight_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Dangerous rights found in OU delegation.
        /// </summary>
        public static string P_DangerousExtendedRight_Title {
            get {
                return ResourceManager.GetString("P_DangerousExtendedRight_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to perform a review of which accounts have ownership rights on a domain controller and can then modify their permissions.
        /// </summary>
        public static string P_DCOwner_Description {
            get {
                return ResourceManager.GetString("P_DCOwner_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Owner: {1}.
        /// </summary>
        public static string P_DCOwner_Detail {
            get {
                return ResourceManager.GetString("P_DCOwner_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DCOwner_Documentation {
            get {
                return ResourceManager.GetString("P_DCOwner_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} domain controller(s) have been found, where the owner is not the Domain Admins group or the Enterprise Admins group.
        /// </summary>
        public static string P_DCOwner_Rationale {
            get {
                return ResourceManager.GetString("P_DCOwner_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_DCOwner_ReportLocation {
            get {
                return ResourceManager.GetString("P_DCOwner_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve this security issue, you should change the ownership of the domain controller to match the &quot;Domain Administrators&quot; group.
        ///To control the ownership of domain controller objects, you can use the following PowerShell command: 
        ///&lt;i&gt;Get-ADComputer -server my.domain.to.check -LDAPFilter &quot;(&amp;(objectCategory=computer)(|(primarygroupid=521)(primarygroupid=516)))&quot; -properties name, ntsecuritydescriptor | select name,{$_.ntsecuritydescriptor.Owner}&lt;/i&gt;.
        ///To change it you can edit the owner of an object using  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DCOwner_Solution {
            get {
                return ResourceManager.GetString("P_DCOwner_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, the &quot;Domain Administrators&quot; group or the &quot;Enterprise Administrators&quot; group are set as owners for &quot;Domain Controllers&quot;. Nonetheless, in some cases (for instance when the server has been promoted from an existing server), the owner can be a non-admin person which joined the server to the domain. If this person has still rights over this account, it can be used to take ownership over the whole domain. A chain of compromising events can be designed to take control of the domain by including this acc [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DCOwner_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DCOwner_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one domain controller is not owned correctly.
        /// </summary>
        public static string P_DCOwner_Title {
            get {
                return ResourceManager.GetString("P_DCOwner_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all Administrator Accounts have the configuration flag &quot;this account is sensitive and cannot be delegated&quot; (or are members of the built-in group &quot;Protected Users&quot; when your domain functional level is at least Windows Server 2012 R2)..
        /// </summary>
        public static string P_Delegated_Description {
            get {
                return ResourceManager.GetString("P_Delegated_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Reason: {1}.
        /// </summary>
        public static string P_Delegated_Detail {
            get {
                return ResourceManager.GetString("P_Delegated_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_Delegated_Documentation {
            get {
                return ResourceManager.GetString("P_Delegated_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Admin accounts which do not have the flag &quot;This account is sensitive and cannot be delegated&quot;: {count}.
        /// </summary>
        public static string P_Delegated_Rationale {
            get {
                return ResourceManager.GetString("P_Delegated_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_Delegated_ReportLocation {
            get {
                return ResourceManager.GetString("P_Delegated_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To correct the situation, you should make sure that all your Administrator Accounts have the check-box &quot;This account is sensitive and cannot be delegated&quot; active or add your Administrator Accounts to the built-in group &quot;Protected Users&quot; if your domain functional level is at least Windows Server 2012 R2 (some functionalities may not work properly afterwards, you should check the &lt;a href=&quot;https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/how-to-configure-protected-accounts&quot;&gt;official docum [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_Delegated_Solution {
            get {
                return ResourceManager.GetString("P_Delegated_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Without the flag &quot;This account is sensitive and cannot be delegated&quot; any account can be impersonated by some service account. It is a best practice to enforce this flag on administrators accounts..
        /// </summary>
        public static string P_Delegated_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_Delegated_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one administrator account can be delegated.
        /// </summary>
        public static string P_Delegated_Title {
            get {
                return ResourceManager.GetString("P_Delegated_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no constrained delegations are applied to DC.
        /// </summary>
        public static string P_DelegationDCa2d2_Description {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Delegate: {1} Identifier: {2}.
        /// </summary>
        public static string P_DelegationDCa2d2_Detail {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationDCa2d2_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC with a constrained delegation: {count}.
        /// </summary>
        public static string P_DelegationDCa2d2_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationDCa2d2_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should edit the msDS-AllowedToDelegateTo attribute of the accounts listed below to remove the SPN of the domain controllers involved.
        ///    .
        /// </summary>
        public static string P_DelegationDCa2d2_Solution {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A constrained delegation is a delegation with some limitation.
        ///    In this case, it is a limitation of the technical service a delegate can call (SPN).
        ///    But in practice, the specific service name is not checked and the delegate can impersonate anyone on all services of a computer.
        ///    For the case of a domain controller, that means that the delegate can take the control of the domain by impersonating a domain admin and doing modifications with the LDAP service.
        ///    This delegation is set via the attr [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DelegationDCa2d2_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC have no constrained delegation..
        /// </summary>
        public static string P_DelegationDCa2d2_Title {
            get {
                return ResourceManager.GetString("P_DelegationDCa2d2_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure role-based constrained delegation is never set on a domain controller..
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Description {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Delegate: {1} Identifier: {2}.
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Detail {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://blog.stealthbits.com/resource-based-constrained-delegation-abuse/.
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC with a resource based constrained delegation: {count}.
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationDCsourcedeleg_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to  Ensure every DC’s &quot;msDS-AllowedToActOnBehalfOfOtherIdentity&quot; attribute is empty.
        ///    Fix a single Domain Controller use the Powershell command:
        ///    &lt;i&gt;Set-ADComputer &amp;lt;DC-NAME&amp;gt; -PrincipalsAllowedToDelegateToAccount $null&lt;/i&gt;
        ///    Fix all Domain Controllers by removing every principal from the RBCD list on the DC, use the Powershell command:
        ///	&lt;i&gt;Get-ADDomainController -Filter * | ForEach-Object { Set-ADComputer -Identity $_.ComputerObjectDN -PrincipalsAllowedToDelegateToAccount $null }&lt;/i&gt;
        ///    .
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Solution {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain Controllers (DCs) must &lt;i&gt;never&lt;/i&gt; allow Resource‑Based Constrained Delegation (RBCD).
        ///    If any security principal (user, computer, or managed service account) is listed in a DC’s  &quot;msDS-AllowedToActOnBehalfOfOtherIdentity&quot; attribute, an attacker who compromises that principal can request &lt;i&gt;S4U2self/S4U2proxy&lt;/i&gt; service tickets and impersonate &lt;i&gt;any&lt;/i&gt; account to the DC, effectively granting themselves _Domain Admin_ privileges.
        ///	This is a direct, reliable path to full domain compromise.
        ///.
        /// </summary>
        public static string P_DelegationDCsourcedeleg_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC have no resource based constrained delegation..
        /// </summary>
        public static string P_DelegationDCsourcedeleg_Title {
            get {
                return ResourceManager.GetString("P_DelegationDCsourcedeleg_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no constrained delegations with protocol transition are applied to DC.
        /// </summary>
        public static string P_DelegationDCt2a4d_Description {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Delegate: {1} Identifier: {2}.
        /// </summary>
        public static string P_DelegationDCt2a4d_Detail {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationDCt2a4d_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC with a constrained delegation with protocol transition: {count}.
        /// </summary>
        public static string P_DelegationDCt2a4d_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationDCt2a4d_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should edit the msDS-AllowedToDelegateTo attribute of the accounts listed below to remove the SPN of the domain controllers involved.
        ///    .
        /// </summary>
        public static string P_DelegationDCt2a4d_Solution {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A constrained delegation with protocol transition is a delegation with some limitation.
        ///    In this case, it is a limitation of the technical service a delegate can call (SPN).
        ///    But in practice, the specific service name is not checked and the delegate can impersonate anyone on all services of a computer.
        ///    For the case of a domain controller, that means that the delegate can take the control of the domain by impersonating a domain admin and doing modifications with the LDAP service.
        ///    This deleg [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DelegationDCt2a4d_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC have no constrained delegation with protocol transition..
        /// </summary>
        public static string P_DelegationDCt2a4d_Title {
            get {
                return ResourceManager.GetString("P_DelegationDCt2a4d_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify that there is no delegation granted to &quot;Everyone&quot; or to &quot;Authenticated Users&quot;.
        /// </summary>
        public static string P_DelegationEveryone_Description {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} delegation: {1} right: {2}.
        /// </summary>
        public static string P_DelegationEveryone_Detail {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationEveryone_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of delegation where anybody can act: {count}.
        /// </summary>
        public static string P_DelegationEveryone_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| enables secure delegation of Active Directory administration with fine-grained permissions, ensuring precise control and accountability over delegated access.\r\nNetwrix Access Analyzer| detects shadow access and excessive permissions, enabling organizations to remediate improper delegation and enforce least privilege.\r\nNetwrix Threat Manager| enhances security by detecting threats related to privilege escalation, so you can investigate suspicicous activity promptly and take app [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DelegationEveryone_RelevantProducts {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationEveryone_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review the delegation to remove this permission and if needed, set a more targeted group as recipient of the delegation..
        /// </summary>
        public static string P_DelegationEveryone_Solution {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To delegate control to a OU, access checks can be modified. In case of a misconfiguration, access can be granted to the group &quot;Everyone&quot; or &quot;Authenticated Users&quot;..
        /// </summary>
        public static string P_DelegationEveryone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Delegation is granted to Everyone.
        /// </summary>
        public static string P_DelegationEveryone_Title {
            get {
                return ResourceManager.GetString("P_DelegationEveryone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that files deployed to computers cannot be changed by everyone..
        /// </summary>
        public static string P_DelegationFileDeployed_Description {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Type: {1} FileName: {2} Account: {3} Right: {4}.
        /// </summary>
        public static string P_DelegationFileDeployed_Detail {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationFileDeployed_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one GPO is deploying a file which can be modified by everyone.
        /// </summary>
        public static string P_DelegationFileDeployed_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpodeployedfiles&quot;&gt;GPO Deployed Files&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationFileDeployed_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the file mentioned by the GPO specified in Details and change its permissions..
        /// </summary>
        public static string P_DelegationFileDeployed_Solution {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Applications and other files can be deployed by a GPO. If an attacker can modify one of these files, they may be able to compromise the user&apos;s account..
        /// </summary>
        public static string P_DelegationFileDeployed_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that files deployed by a GPO cannot be modified by everyone..
        /// </summary>
        public static string P_DelegationFileDeployed_Title {
            get {
                return ResourceManager.GetString("P_DelegationFileDeployed_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that standard users cannot modify GPO.
        /// </summary>
        public static string P_DelegationGPOData_Description {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Item: {1} Account: {2} Right: {3}.
        /// </summary>
        public static string P_DelegationGPOData_Detail {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationGPOData_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of GPO items that can be modified by any user: {count}.
        /// </summary>
        public static string P_DelegationGPOData_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Auditor| monitors and alerts on GPO changes with detailed visibility into who made changes, what was modified, and when, enabling swift response..
        /// </summary>
        public static string P_DelegationGPOData_RelevantProducts {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the Access Control List (ACL) of the GPO object or the directory where the items is located. Then remove any write permission given to the group..
        /// </summary>
        public static string P_DelegationGPOData_Solution {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When the group Authenticated Users, Everyone or any similar groups have permission to modify a GPO, it can be abused to take control of the accounts where this GPO applies. It can potentially lead to the compromise of the domain.
        /// </summary>
        public static string P_DelegationGPOData_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that GPO items cannot be modified by any user.
        /// </summary>
        public static string P_DelegationGPOData_Title {
            get {
                return ResourceManager.GetString("P_DelegationGPOData_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no weaknesses have been introduced following a Windows Server 2016 installation..
        /// </summary>
        public static string P_DelegationKeyAdmin_Description {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Account: {1} Right: {2}.
        /// </summary>
        public static string P_DelegationKeyAdmin_Detail {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://itpro-tips.com/wp-content/uploads/files/TechnetGallery/Enterprise-Key-Admins-720eb270.zip
        ///https://secureidentity.se/adprep-bug-in-windows-server-2016/.
        /// </summary>
        public static string P_DelegationKeyAdmin_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A bogus Windows Server 2016 installation has granted too many rights to the Enterprise Key Admins group.
        /// </summary>
        public static string P_DelegationKeyAdmin_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationKeyAdmin_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to After having carefully studied the possible impact of the following change, apply the script made by MSRC and referenced in the documentation below to alter the permission..
        /// </summary>
        public static string P_DelegationKeyAdmin_Solution {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to After performing adprep /domainprep from Windows Server 2016 sources there may be an unwanted AccessControlEntry (ACE) in the DiscretionaryACL (DACL) of the targeted domain-naming-context&apos;s SecurityDescriptor (SD) that grants FullControl permission to the Enterprise Key Admins group ( SID = ending with -527 ).
        ///This is s a bug in ADPREP that was fixed in Windows Server 2016 RS3/1709. No official fix for those who used pre-1709.
        ///Note: The SID will only be resolvable after the PDC emulator role is transferre [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DelegationKeyAdmin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that bogus Windows Server 2016 AD prep did not introduce vulnerabilities.
        /// </summary>
        public static string P_DelegationKeyAdmin_Title {
            get {
                return ResourceManager.GetString("P_DelegationKeyAdmin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that standard users cannot modify login scripts.
        /// </summary>
        public static string P_DelegationLoginScript_Description {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Script: {0} Account: {1} Right: {2}.
        /// </summary>
        public static string P_DelegationLoginScript_Detail {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DelegationLoginScript_Documentation {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of login scripts that can be modified by any user: {count}.
        /// </summary>
        public static string P_DelegationLoginScript_Rationale {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Endpoint Policy Manager| can help ensure that all login scripts cannot be modified by any user by utilizing its application control and security policies. Specifically, Netwrix Endpoint Policy Manager provides the capability to lock down application settings and restrict user permissions, which prevents unauthorized modifications to login scripts..
        /// </summary>
        public static string P_DelegationLoginScript_RelevantProducts {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpologin&quot;&gt;GPO Login script&lt;/a&gt;.
        /// </summary>
        public static string P_DelegationLoginScript_ReportLocation {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the Access Control List (ACL) of the script object or the directory where the file is located. Then remove any write permission given to the group..
        /// </summary>
        public static string P_DelegationLoginScript_Solution {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When the group Authenticated Users, Everyone or any similar groups have permission to modify a login script, it can be abused to take control of the accounts using this script. It can potentially lead to the compromise of the domain.
        /// </summary>
        public static string P_DelegationLoginScript_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that all login scripts cannot be modified by any user.
        /// </summary>
        public static string P_DelegationLoginScript_Title {
            get {
                return ResourceManager.GetString("P_DelegationLoginScript_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that scripts used for the customization of admin UI are stored safely.
        /// </summary>
        public static string P_DisplaySpecifier_Description {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Path: {1} Changed: {2}.
        /// </summary>
        public static string P_DisplaySpecifier_Detail {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.semperis.com/blog/active-directory-security-abusing-display-specifiers/
        ///https://learn.microsoft.com/en-us/windows/win32/ad/display-specifiers.
        /// </summary>
        public static string P_DisplaySpecifier_Documentation {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DisplaySpecifier scripts have been identified and they are not stored in the SYSVOL directory..
        /// </summary>
        public static string P_DisplaySpecifier_Rationale {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DisplaySpecifier_ReportLocation {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The scripts identified by this rule should be moved to the SYSVOL and properly secured..
        /// </summary>
        public static string P_DisplaySpecifier_Solution {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DisplaySpecifier are Active Directory objects stored in the DisplaySpecifier container of the Configuration naming context.
        ///    They are used to customize the user interface.
        ///    Specifically the attribute adminContextMenu is used to customize administration actions, where COM objects or scripts can be called.
        ///    If the script is stored outside the SYSVOL directory, it can be used to execute custom actions and it is run under the administrator context.
        ///    .
        /// </summary>
        public static string P_DisplaySpecifier_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that custom Display Specifiers are stored in SYSVOL.
        /// </summary>
        public static string P_DisplaySpecifier_Title {
            get {
                return ResourceManager.GetString("P_DisplaySpecifier_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the Dns Admins group is not used.
        /// </summary>
        public static string P_DNSAdmin_Description {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_DNSAdmin_Detail {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/007efcd2-2955-46dd-a59e-f83ae88f4678.
        /// </summary>
        public static string P_DNSAdmin_Documentation {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of members of the Dns Admins group: {count}.
        /// </summary>
        public static string P_DNSAdmin_Rationale {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_DNSAdmin_ReportLocation {
            get {
                return ResourceManager.GetString("P_DNSAdmin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rule update:
        ///The Patch Tuesday of October 2021 fixed this vulnerability and assigned it the identifier CVE-2021-40469.
        ///If the patch has been applied, there is no additional mitigation to perform.
        ///
        ///This rule is transformed into an informative rule in PingCastle 2.10.1 and will be removed in future versions of PingCastle.
        ///
        ///You should remove the members of the Dns Admins group and do a proper delegation to the specific DNS Zones.
        ///
        ///First, grant only &quot;Read Property&quot;, &quot;List&quot;, &quot;List object&quot; and &quot;Read perms [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DNSAdmin_Solution {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Administrators of the DNS Service have the possibility to inject a DLL in this service.
        ///However this service is hosted most of the time in the domain controller and is running as SYSTEM.
        ///That means that DNS admins are potentially domain admins.
        ///
        ///The security descriptor used to grant admin rights is located on the nTSecurityDescriptor attribute of the object CN=MicrosoftDNS,CN=System.
        ///The &quot;Write All Prop&quot; access right induces the vulnerability.
        ///
        ///In this case, the DnsAdmins group is not empty and grant [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DNSAdmin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DNSAdmin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the Dns Admins group is not empty.
        /// </summary>
        public static string P_DNSAdmin_Title {
            get {
                return ResourceManager.GetString("P_DNSAdmin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no specific delegation has been setup to manage the Microsoft DNS..
        /// </summary>
        public static string P_DNSDelegation_Description {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account: {0} Right: {1}.
        /// </summary>
        public static string P_DNSDelegation_Detail {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/007efcd2-2955-46dd-a59e-f83ae88f4678
        ///https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40469
        ///https://blog.0patch.com/2021/11/micropatch-for-remote-code-execution-by.html.
        /// </summary>
        public static string P_DNSDelegation_Documentation {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An explicit delegation has been put in place to manage the Microsoft DNS service..
        /// </summary>
        public static string P_DNSDelegation_Rationale {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_DNSDelegation_ReportLocation {
            get {
                return ResourceManager.GetString("P_DNSDelegation_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rule update:
        ///The Patch Tuesday of October 2021 fixed this vulnerability and assigned it the identifier CVE-2021-40469.
        ///If the patch has been applied, there is no additional mitigation to perform.
        ///
        ///This rule is transformed into an informative rule in PingCastle 2.10.1 and will be removed in future versions of PingCastle.
        ///      
        ///      You should remove the explicit write delegation located in the CN=MicrosoftDNS,CN=System container and do a proper delegation.
        ///    First, grant only &quot;Read Property&quot;, &quot;Lis [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DNSDelegation_Solution {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Administrators of the DNS Service have the possibility to inject a DLL in this service.
        ///However this service is hosted most of the time in the domain controller and is running as SYSTEM.
        ///That means that DNS Admins are potentially domain admins.
        ///
        ///The security descriptor used to grant admin rights is located on the nTSecurityDescriptor attribute of the object CN=MicrosoftDNS,CN=System.
        ///The &quot;Write All Prop&quot; access right induces the vulnerability.
        ///
        ///In this case, an explicit delegation has been setup and  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DNSDelegation_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DNSDelegation_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is an explicit delegation on DNS servers..
        /// </summary>
        public static string P_DNSDelegation_Title {
            get {
                return ResourceManager.GetString("P_DNSDelegation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the AdminSDHolder mechanism has not been altered.
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_Description {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.petri.com/active-directory-security-understanding-adminsdholder-object
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5.
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_Documentation {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The AdminSDHolder safety mechanism has been modified for some privilege groups.
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_Rationale {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| helps enforce policies to block unauthorized changes to the AdminSDHolder object and ensure critical group protections remain intact, preventing privilege escalation. .
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_RelevantProducts {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Find the dsHeuristics configuration which is located in CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=ad,DC=contoso,DC=com.
        ///    Then edit the 16th character and set it to zero..
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_Solution {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The AdminSDHolder service is a protection which prohibits an admin to lose control of the domain after a permission change or to introduce a weakness in the permissions.
        ///It proceeds by rewriting every 60 minutes the security descriptor of critical objects.
        ///
        ///By modifying the dsHeuristics attribute, this protection can be disabled for one or more critical group.
        ///Each critical group is associated with a value:
        ///Account Operators: 1,
        ///Server Operators: 2,
        ///Print Operators:4,
        ///Backup Operators: 8.
        ///The 16th  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the AdminSDHolder protection has not been disabled for some critical groups.
        /// </summary>
        public static string P_DsHeuristicsAdminSDExMask_Title {
            get {
                return ResourceManager.GetString("P_DsHeuristicsAdminSDExMask_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if the DoListObject feature has been enabled.
        /// </summary>
        public static string P_DsHeuristicsDoListObject_Description {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://dirteam.com/sander/2008/12/09/active-directory-visibility-modes/
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e5899be4-862e-496f-9a38-33950617d2c5
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/990fb975-ab31-4bc1-8b75-5da132cd4584.
        /// </summary>
        public static string P_DsHeuristicsDoListObject_Documentation {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The DoListObject has been enabled.
        /// </summary>
        public static string P_DsHeuristicsDoListObject_Rationale {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is an informative rule.
        ///If you want to reverse this behavior to its default value, find the dsHeuristics configuration which is located in CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=ad,DC=contoso,DC=com.
        ///Then edit the 3rd character and set it to zero..
        /// </summary>
        public static string P_DsHeuristicsDoListObject_Solution {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The DoListObject is a feature to probihit account located in an OU to look at another OU. It proceeds by checking a special ACL named RIGHT_DS_LIST_OBJECT.
        ///.
        /// </summary>
        public static string P_DsHeuristicsDoListObject_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the behavior DoListObject has been enabled.
        /// </summary>
        public static string P_DsHeuristicsDoListObject_Title {
            get {
                return ResourceManager.GetString("P_DsHeuristicsDoListObject_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no weakness has been introduced at Exchange installation..
        /// </summary>
        public static string P_ExchangeAdminSDHolder_Description {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/blog/exchange/exchange-2010-and-resolution-of-the-adminsdholder-elevation-issue/598497.
        /// </summary>
        public static string P_ExchangeAdminSDHolder_Documentation {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exchange did alter the AdminSDHolder object.
        /// </summary>
        public static string P_ExchangeAdminSDHolder_Rationale {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| detects and optionally blocks unauthorized changes to AdminSDHolder permissions, helping to prevent privilege escalation and protect your Active Directory. .
        /// </summary>
        public static string P_ExchangeAdminSDHolder_RelevantProducts {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_ExchangeAdminSDHolder_ReportLocation {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to After having carefully studied the possible impact of the following change, alter the AdminSDHolder permissions to remove the Exchange objects..
        /// </summary>
        public static string P_ExchangeAdminSDHolder_Solution {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At install time, the Exchange Windows Permissions universal security group (USG) was granted the ability to modify the members attribute, the ability to change and reset passwords, and the ability to modify the permissions of any object protected by the AdminSDHolder role.
        ///    This security group includes all the Exchange servers.
        ///    As a consequence, a malicious administrator could elevate their privileges on one of the servers and thus gain control of the Active Directory forest.
        ///    Newest versions o [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_ExchangeAdminSDHolder_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that Exchange did not modify the AdminSDHolder object to introduce vulnerabilities.
        /// </summary>
        public static string P_ExchangeAdminSDHolder_Title {
            get {
                return ResourceManager.GetString("P_ExchangeAdminSDHolder_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that Exchange installation did not introduce privilege escalation vulnerabilities by modifying domain permissions.
        /// </summary>
        public static string P_ExchangePrivEsc_Description {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/gdedrouas/Exchange-AD-Privesc/blob/master/DomainObject/Fix-DomainObjectDACL.ps1
        ///https://techcommunity.microsoft.com/blog/exchange/released-february-2019-quarterly-exchange-updates/609061
        ///https://support.microsoft.com/en-us/help/4490059/using-shared-permissions-model-to-run-exchange-server.
        /// </summary>
        public static string P_ExchangePrivEsc_Documentation {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The group Exchange Windows Permissions has the right to change the security descriptor of the domain root.
        /// </summary>
        public static string P_ExchangePrivEsc_Rationale {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the root domain security descriptor. Identify the ACE giving the right ModifyDACL to the principal Exchange Windows Permissions. Go to the advanced settings and set the inheritance to Inherit Only.
        ///    
        ///Or run the PowerShell script Fix-DomainObjectDACL.ps1 referenced below..
        /// </summary>
        public static string P_ExchangePrivEsc_Solution {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When Exchange is installed, a set of permissions is modified to allow a deep Windows integration. A dependency analysis has shown that the permissions, that Exchange has set, introduced a possibility for privilege escalation.
        ///    The most basic exploitation is that a member of the group Exchange Windows Permissions can modify the security permission of the domain, granting itself the right Ds-Replication-Get-Changes-All.
        ///    This right allows the account to perform an attack named DCSync, which retrieves  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_ExchangePrivEsc_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that Exchange did not introduce security vulnerabilities.
        /// </summary>
        public static string P_ExchangePrivEsc_Title {
            get {
                return ResourceManager.GetString("P_ExchangePrivEsc_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all Administrator Accounts in the AD are necessary and used.
        /// </summary>
        public static string P_Inactive_Description {
            get {
                return ResourceManager.GetString("P_Inactive_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_Inactive_Documentation {
            get {
                return ResourceManager.GetString("P_Inactive_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to More than {threshold}% of admins are inactive: {count}%.
        /// </summary>
        public static string P_Inactive_Rationale {
            get {
                return ResourceManager.GetString("P_Inactive_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| enforces lifecycle management for identities and their associated accounts, eliminating standing admin accounts by requiring users to request permissions only when needed.\r\nNetwrix Auditor| monitors and alerts on activity from inactive admin accounts, enabling early detection of potential misuse or malicious activity. .
        /// </summary>
        public static string P_Inactive_RelevantProducts {
            get {
                return ResourceManager.GetString("P_Inactive_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To correct the situation, you should make sure that all your Administrator Account(s) are &quot;Active&quot;, meaning that you should remove Administrator rights if an account is set as not &quot;Active&quot;.
        /// </summary>
        public static string P_Inactive_Solution {
            get {
                return ResourceManager.GetString("P_Inactive_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Accounts within the AD have attributes indicating the creation date of the account and the last login of this account. Accounts which haven&apos;t have a login since 6 months or created more than 6 months ago without any login are considered inactive. If an Administrator Account is set as inactive, the reason for having Administrator rights should be strongly justified..
        /// </summary>
        public static string P_Inactive_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_Inactive_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for inactive administrator accounts.
        /// </summary>
        public static string P_Inactive_Title {
            get {
                return ResourceManager.GetString("P_Inactive_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the password of admin accounts cannot be retrieved using the Kerberoast attack..
        /// </summary>
        public static string P_Kerberoasting_Description {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User: {0} Groups: {1} SPNs: {2}.
        /// </summary>
        public static string P_Kerberoasting_Detail {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://adsecurity.org/?p=3466.
        /// </summary>
        public static string P_Kerberoasting_Documentation {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one member of an admin group is vulnerable to the Kerberoast attack..
        /// </summary>
        public static string P_Kerberoasting_Rationale {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_Kerberoasting_ReportLocation {
            get {
                return ResourceManager.GetString("P_Kerberoasting_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the account is a service account, the service should be removed from the privileged group or have a process to change its password at a regular basis.
        ///If the user is a person, the SPN attribute of the account should be removed..
        /// </summary>
        public static string P_Kerberoasting_Solution {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To access a service using Kerberos, a user requests a ticket (named TGS) to the DC specific to the service.
        ///This ticket is encrypted using a derivative of the service password, but can be brute-forced to retrieve the original password.
        ///Any account having the attribute SPN populated is considered as a service account.
        ///Given that any user can request a ticket for a service account, these accounts can have their password retrieved.
        ///In addition, services are known to have their password not changed at a reg [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_Kerberoasting_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_Kerberoasting_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if admin accounts are vulnerable to the Kerberoast attack..
        /// </summary>
        public static string P_Kerberoasting_Title {
            get {
                return ResourceManager.GetString("P_Kerberoasting_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that standard users cannot login to domain controllers.
        /// </summary>
        public static string P_LoginDCEveryone_Description {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Account: {1} Privilege: {2}.
        /// </summary>
        public static string P_LoginDCEveryone_Detail {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/allow-log-on-locally
        ///https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/allow-log-on-through-remote-desktop-services
        ///https://support.hpe.com/hpsc/doc/public/display?docId=emr_na-c04197764-1.
        /// </summary>
        public static string P_LoginDCEveryone_Documentation {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Anyone can interactively or remotely login to a DC.
        /// </summary>
        public static string P_LoginDCEveryone_Rationale {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Privilege Secure| dynamically grants logon rights to administrators only when needed and disables RDP access when not in use, minimizing the attack surface and reducing the risk of unauthorized access..
        /// </summary>
        public static string P_LoginDCEveryone_RelevantProducts {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpoprivileges&quot;&gt;Privileges&lt;/a&gt;.
        /// </summary>
        public static string P_LoginDCEveryone_ReportLocation {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the GPO specified in Details and remove the privilege &quot;Allow log on locally&quot; or &quot;Allow log on through Remote Desktop Services&quot; to &quot;Everyone&quot;, &quot;Authenticated Users&quot;, &quot;Domain Users&quot; or &quot;Domain Computers&quot;.
        ///The settings are located in :
        ///    Computer configuration -&gt; Policies -&gt; Windows Settings -&gt;Security Settings -&gt; Local Policies -&gt; User Rights Assignment.
        ///As an alternative, the file GptTmpl.inf can be manually edited..
        /// </summary>
        public static string P_LoginDCEveryone_Solution {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain Controllers are critical components of the Active Directory. If an attacker is able to open a session, he will be able to discover insecure backup media or perform a local privilege escalation to become the DC admin and thus the AD admin.
        ///    Local logon requires usually physical interaction, which explains why network seggregation is a best practice, but this can be bypassed. Indeed, VNC or remote server management software is a way to perform local logon remotely.
        ///    In addition, remote server m [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_LoginDCEveryone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the privilege to log on Domain Controllers are not granted to everyone by GPO.
        /// </summary>
        public static string P_LoginDCEveryone_Title {
            get {
                return ResourceManager.GetString("P_LoginDCEveryone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is a tier isolation..
        /// </summary>
        public static string P_LogonDenied_Description {
            get {
                return ResourceManager.GetString("P_LogonDenied_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_LogonDenied_Detail {
            get {
                return ResourceManager.GetString("P_LogonDenied_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-f--securing-domain-admins-groups-in-active-directory.
        /// </summary>
        public static string P_LogonDenied_Documentation {
            get {
                return ResourceManager.GetString("P_LogonDenied_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No GPO preventing the logon of administrators has been found..
        /// </summary>
        public static string P_LogonDenied_Rationale {
            get {
                return ResourceManager.GetString("P_LogonDenied_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpologin&quot;&gt;GPO Login&lt;/a&gt;.
        /// </summary>
        public static string P_LogonDenied_ReportLocation {
            get {
                return ResourceManager.GetString("P_LogonDenied_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should add a GPO to prohibit the logon of specific groups Domain Admins and Administrators.
        ///    
        ///The setting is located in Computer Policy -&gt; Computer Configuration -&gt; Windows Settings -&gt; Security Settings -&gt; Local Policies -&gt; User Rights Assignment.
        ///Then &quot;Deny&quot; logon locally and &quot;Deny&quot; logon through Remote Desktop Services..
        /// </summary>
        public static string P_LogonDenied_Solution {
            get {
                return ResourceManager.GetString("P_LogonDenied_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A way to collect an administrator credential is to take control of a workstation or server in the unsecured tiers and expect that an administrator will connect to it.
        ///    An attack such as credential theft or Kerberos delegation is then performed.
        ///    To reduce the impact of such compromise, the best practice is to isolate components (such as admins, DC) in tiers.
        ///    Typically, a domain admin should not be allowed to connect to any workstation or lower tier server but login only to perform highly privil [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_LogonDenied_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_LogonDenied_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is a policy preventing administrators to connect to lower tier systems..
        /// </summary>
        public static string P_LogonDenied_Title {
            get {
                return ResourceManager.GetString("P_LogonDenied_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the operator groups, which can have indirect control to the domain, are empty.
        /// </summary>
        public static string P_OperatorsEmpty_Description {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Group: {0} Members: {1}.
        /// </summary>
        public static string P_OperatorsEmpty_Detail {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_OperatorsEmpty_Documentation {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} operator group(s) are not empty.
        /// </summary>
        public static string P_OperatorsEmpty_Rationale {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_OperatorsEmpty_ReportLocation {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is recommended to have these groups empty. Assign administrators into administrators group. Other accounts should have proper delegation rights in an OU or in the scope they are managing..
        /// </summary>
        public static string P_OperatorsEmpty_Solution {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operator groups (Account Operators, Server Operators, ...) can take indirect control of the domain. Indeed, these groups have write access to critical resources of the domain..
        /// </summary>
        public static string P_OperatorsEmpty_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check that the operator groups are empty.
        /// </summary>
        public static string P_OperatorsEmpty_Title {
            get {
                return ResourceManager.GetString("P_OperatorsEmpty_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that dangerous privileges are not being granted to all users.
        /// </summary>
        public static string P_PrivilegeEveryone_Description {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Account: {1} Privilege: {2}.
        /// </summary>
        public static string P_PrivilegeEveryone_Detail {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.romhack.io/slides/RomHack%202018%20-%20Andrea%20Pierini%20-%20whoami%20priv%20-%20show%20me%20your%20Windows%20privileges%20and%20I%20will%20lead%20you%20to%20SYSTEM.pdf
        ///https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/
        ///https://github.com/decoder-it/psgetsystem
        ///https://twitter.com/0gtweet/status/1303427935647531018?s=20.
        /// </summary>
        public static string P_PrivilegeEveryone_Documentation {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of privileges granted to all users by the GPO: {count}.
        /// </summary>
        public static string P_PrivilegeEveryone_Rationale {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Auditor| monitors and alerts on GPO changes, ensuring immediate visibility into security risks.\r\nNetwrix Threat Manager| detects and optionally blocks unauthorized GPO changes that assign dangerous privileges to broad groups like &quot;Everyone&quot;, protecting your environment proactively. \r\nNetwrix Endpoint Privilege Manager| mitigates the risk of dangerous privileges via least privilege management, ensuring users have only necessary access. It creates granular policies for controlling administrative r [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_PrivilegeEveryone_RelevantProducts {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpoprivileges&quot;&gt;Privileges&lt;/a&gt;.
        /// </summary>
        public static string P_PrivilegeEveryone_ReportLocation {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the GPO specified in Details and remove the privilege.
        ///Most of the settings are located in :
        ///    Computer configuration -&gt; Policies -&gt; Windows Settings -&gt;Security Settings -&gt; Local Policies -&gt; User Rights Assignment.
        ///As an alternative, the file GptTmpl.inf can be manually edited..
        /// </summary>
        public static string P_PrivilegeEveryone_Solution {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To perform special operations, the operating system relies on privileges. They can be displayed by running the command: whoami /all.
        ///SeLoadDriverPrivilege can be used to take control of the system by loading a specifically designed driver. This procedure can be performed by low privileged users as the driver can be defined in HKCU.
        ///SeTcbPrivilege is the privilege used to &quot;Act on behalf the operating system&quot;. This is the privilege reserved to the SYSTEM user. This procedure allows any user to act as SYSTEM [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_PrivilegeEveryone_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that dangerous privileges are not granted to everyone by GPO.
        /// </summary>
        public static string P_PrivilegeEveryone_Title {
            get {
                return ResourceManager.GetString("P_PrivilegeEveryone_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all privileged accounts are in the Protected User security group.
        /// </summary>
        public static string P_ProtectedUsers_Description {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User: {0}.
        /// </summary>
        public static string P_ProtectedUsers_Detail {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/protected-users-security-group
        ///https://blog.netwrix.com/2015/02/20/add-sensitive-user-accounts-to-active-directory-protected-users-group/
        ///https://dirteam.com/sander/2014/11/25/ten-things-you-need-to-be-aware-of-before-using-the-protected-users-group/
        ///https://blog.andreas-schreiner.de/2018/09/07/active-directory-sicherheit-teil-1-privilegierte-benutzer/.
        /// </summary>
        public static string P_ProtectedUsers_Documentation {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of admins not in Protected Users: {count}.
        /// </summary>
        public static string P_ProtectedUsers_Rationale {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_ProtectedUsers_ReportLocation {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to After having reviewed the potential impact on adding users to this group, add the missing privileged accounts to this group..
        /// </summary>
        public static string P_ProtectedUsers_Solution {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Protected User group is a special security group which automatically applies protections to minimize credential exposure. Starting with Windows 8.1. Older Operating System must be updated to take this protection in account such as the Windows 7 KB2871997 patch.
        ///    For admins, it:
        ///- Disables NTLM authentication
        ///- Reduces Kerberos ticket lifetime
        ///- Mandates strong encryption algorithms, such as AES
        ///- Prevents password caching on workstations
        ///- Prevents any type of Kerberos delegation
        ///
        ///Please also [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_ProtectedUsers_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all privileged accounts are in the special group Protected Users..
        /// </summary>
        public static string P_ProtectedUsers_Title {
            get {
                return ResourceManager.GetString("P_ProtectedUsers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check that it is not possible to go into recovery mode without the administrator password.
        /// </summary>
        public static string P_RecoveryModeUnprotected_Description {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string P_RecoveryModeUnprotected_Detail {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/recovery-console-allow-automatic-administrative-logon.
        /// </summary>
        public static string P_RecoveryModeUnprotected_Documentation {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one GPO grants the right to get in recovery mode without being admin.
        /// </summary>
        public static string P_RecoveryModeUnprotected_Rationale {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string P_RecoveryModeUnprotected_ReportLocation {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the GPO specified in Details and turn off the setting &quot;Recovery console: Allow automatic administrative logon&quot;
        ///The setting is located in :
        ///    Computer configuration -&gt; Policies -&gt; Windows Settings -&gt;Security Settings -&gt; Local Policies -&gt; Security Options.
        ///As an alternative, the file GptTmpl.inf can be manually edited..
        /// </summary>
        public static string P_RecoveryModeUnprotected_Solution {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The recovery mode is a special mode allowing an admin to fix an issue preventing the computer to boot. By pressing F8 in the short time span allowed, the computer boots with just a simple command line.
        ///    Usually, the administrator password is requested to avoid that people having physical access get control of it. It can typically be done by creating a new user account and add this account as member of the administrators group. This rule checks if there are GPOs which disable this password prompt..
        /// </summary>
        public static string P_RecoveryModeUnprotected_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure the &quot;automatic administrative logon&quot; feature of the recovery mode is not enabled.
        /// </summary>
        public static string P_RecoveryModeUnprotected_Title {
            get {
                return ResourceManager.GetString("P_RecoveryModeUnprotected_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the Recycle Bin feature is enabled.
        /// </summary>
        public static string P_RecycleBin_Description {
            get {
                return ResourceManager.GetString("P_RecycleBin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://enterinit.com/powershell-enable-active-directory-recycle-bin.
        /// </summary>
        public static string P_RecycleBin_Documentation {
            get {
                return ResourceManager.GetString("P_RecycleBin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Recycle Bin is not enabled.
        /// </summary>
        public static string P_RecycleBin_Rationale {
            get {
                return ResourceManager.GetString("P_RecycleBin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Recovery for Active Directory| ensures fast, complete restoration of deleted objects with all attributes intact—even if the Recycle Bin was never enabled—minimizing downtime and security risks..
        /// </summary>
        public static string P_RecycleBin_RelevantProducts {
            get {
                return ResourceManager.GetString("P_RecycleBin_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt;.
        /// </summary>
        public static string P_RecycleBin_ReportLocation {
            get {
                return ResourceManager.GetString("P_RecycleBin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to First, be sure that the forest level is at least Windows Server 2008 R2.
        ///    You can check it with Get-ADForest or in the &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt; section.
        ///  Then you can enable it using the PowerShell command:
        ///Enable-ADOptionalFeature -Identity &apos;Recycle Bin Feature&apos; -Scope ForestOrConfigurationSet -Target &apos;test.mysmartlogon.com&apos;.
        /// </summary>
        public static string P_RecycleBin_Solution {
            get {
                return ResourceManager.GetString("P_RecycleBin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Recycle Bin avoids immediate deletion of objects (which can still be partially recovered by its tombstone). This lowers the administration work needed to restore. It also extends the period where traces are available when an investigation is needed..
        /// </summary>
        public static string P_RecycleBin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RecycleBin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the Recycle Bin feature is enabled.
        /// </summary>
        public static string P_RecycleBin_Title {
            get {
                return ResourceManager.GetString("P_RecycleBin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if privileged users have already been revealed.
        /// </summary>
        public static string P_RODCAdminRevealed_Description {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} User: {1}.
        /// </summary>
        public static string P_RODCAdminRevealed_Detail {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/8dfc81be-7461-48f2-8caf-07402bccb0ea.
        /// </summary>
        public static string P_RODCAdminRevealed_Documentation {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one privileged user has been revealed on a RODC.
        /// </summary>
        public static string P_RODCAdminRevealed_Rationale {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_RODCAdminRevealed_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The admin account should have its secrets change (a password reset) and be sure that the account will not be revealed anymore..
        /// </summary>
        public static string P_RODCAdminRevealed_Solution {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On Active Directory, all users revealed to a RODC are tracked by an attribute set on the computer object of the RODC named msDS-RevealedUsers.
        ///    The program checks on the list of revealed users if one of them is known as a privileged user.
        ///  Indeed, the RODC is caching the authentication secrets related of this user, which can then be used to impersonate it.
        ///In addition to that, RODC are placed in general on more riskier environment..
        /// </summary>
        public static string P_RODCAdminRevealed_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if privileged users have been revealed on RODC.
        /// </summary>
        public static string P_RODCAdminRevealed_Title {
            get {
                return ResourceManager.GetString("P_RODCAdminRevealed_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the Allowed RODC Password Replication Group group is empty..
        /// </summary>
        public static string P_RODCAllowedGroup_Description {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member: {0}.
        /// </summary>
        public static string P_RODCAllowedGroup_Detail {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_RODCAllowedGroup_Documentation {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Allowed RODC Password Replication Group group is not empty.
        /// </summary>
        public static string P_RODCAllowedGroup_Rationale {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and alerts on changes to the &quot;Allowed RODC Password Replication Group&quot; membership and can optionally prevent unauthorized modifications with policy-based protection..
        /// </summary>
        public static string P_RODCAllowedGroup_RelevantProducts {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_RODCAllowedGroup_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This group should be emptied, and dedicated groups should only be added to the Password Replication Policy of each relevant RODC..
        /// </summary>
        public static string P_RODCAllowedGroup_Solution {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Accounts belonging to the Allowed RODC Password Replication Group group have their password hashes revealed on all RODCs..
        /// </summary>
        public static string P_RODCAllowedGroup_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the Allowed RODC Password Replication Group group.
        /// </summary>
        public static string P_RODCAllowedGroup_Title {
            get {
                return ResourceManager.GetString("P_RODCAllowedGroup_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the Denied RODC Password Replication Group group has at least its default members..
        /// </summary>
        public static string P_RODCDeniedGroup_Description {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing: {0}.
        /// </summary>
        public static string P_RODCDeniedGroup_Detail {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/services-hub/unified/health/remediation-steps-ad/review-the-removal-of-default-members-from-the-denied-rodc-password-replication-group.
        /// </summary>
        public static string P_RODCDeniedGroup_Documentation {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Denied RODC Password Replication Group group has some of its default members missing.
        /// </summary>
        public static string P_RODCDeniedGroup_Rationale {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks unauthorized changes to the Denied RODC Password Replication Group, ensuring critical objects remain protected from replication and reducing the risk of credential exposure. \r\nNetwrix Directory Manager| provides robust group management and attestation capabilities, helping maintain the integrity..
        /// </summary>
        public static string P_RODCDeniedGroup_RelevantProducts {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_RODCDeniedGroup_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add the items which have been identified as missing to the Denied RODC Password Replication Group group.
        ///    .
        /// </summary>
        public static string P_RODCDeniedGroup_Solution {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A set of critical objects are being forbidden to replicate in RODC for security reasons.
        ///    This permission is set using the Denied RODC Password Replication Group group.
        ///    Removing one of the default members of this group remove this protection, and thus, the isolation of RODC..
        /// </summary>
        public static string P_RODCDeniedGroup_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the Denied RODC Password Replication Group group.
        /// </summary>
        public static string P_RODCDeniedGroup_Title {
            get {
                return ResourceManager.GetString("P_RODCDeniedGroup_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The objective is to assess if krbtgt accounts created for RODC are still associated to a RODC..
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Description {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Created: {1}.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Detail {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/mailbag-rodcs-krbtgt-orphans-and-load-balancing-rodc-connection/ba-p/256064
        ///    https://specterops.io/blog/2023/01/25/at-the-edge-of-tier-zero-the-curious-case-of-the-rodc/.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Documentation {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Orphaned krbtgt accounts are present and not linked to a RODC server.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Rationale {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Firstly, identify the associated Read-Only Domain Controller (RODC) and ensure it has been decommissioned. 
        ///    Note that the user executing the scan might not have the necessary permissions to view the RODC.
        ///    You can utilize the following command to list all RODCs:  &lt;i&gt;Get-ADDomainController -Filter {IsReadOnly -eq $true} &lt;/i&gt;
        ///    
        ///    Following this, proceed to delete the associated krbtgt account.
        ///    Disabling the account will not suffice, as all krbtgt accounts are inherently disabled, serving  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Solution {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos tickets are digitally signed data structures, authenticated by the hash of the well-known krbtgt password.
        ///    To establish a lower trust level, Read-Only Domain Controllers (RODCs) utilize a unique krbtgt account.
        ///    This account is identifiable by its name, which follows the format ‘krbtgt_XXXX’, where ‘XXXX’ represents a numeric sequence.
        ///    Ideally, when an RODC is decommissioned, its corresponding krbtgt account should also be deleted.
        ///    However, this does not always occur as expected. [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Krbtgt accounts created for RODC not associated anymore to a RODC.
        /// </summary>
        public static string P_RODCKrbtgtOrphan_Title {
            get {
                return ResourceManager.GetString("P_RODCKrbtgtOrphan_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the protection against revealing privileged group is active.
        /// </summary>
        public static string P_RODCNeverReveal_Description {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Group: {1}.
        /// </summary>
        public static string P_RODCNeverReveal_Detail {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/8dfc81be-7461-48f2-8caf-07402bccb0ea.
        /// </summary>
        public static string P_RODCNeverReveal_Documentation {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The protection against Privileged Group protection on RODC is not fully enabled.
        /// </summary>
        public static string P_RODCNeverReveal_Rationale {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_RODCNeverReveal_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the value of the attribute msDS-NeverRevealGroup and the presence of the following expected groups:
        ///- Administrators;
        ///- Server Operators;
        ///- Account Operators;
        ///- Backup Operators;
        ///- Denied RODC Password Replication Group
        ///
        ///    This can be managed in the Password Replication Policy tab of the computer object in the Active Directory Users and Computers console..
        /// </summary>
        public static string P_RODCNeverReveal_Solution {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In addition to the group Denied RODC Password Replication Group there is a custom setting set for RODC in an attribute named msDS-NeverRevealGroup.
        ///    This rule checks the current value against the default one..
        /// </summary>
        public static string P_RODCNeverReveal_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the protection against revealing privileged group is active.
        /// </summary>
        public static string P_RODCNeverReveal_Title {
            get {
                return ResourceManager.GetString("P_RODCNeverReveal_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no privileged group can be revealed on RODC.
        /// </summary>
        public static string P_RODCRevealOnDemand_Description {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Account: {1}.
        /// </summary>
        public static string P_RODCRevealOnDemand_Detail {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/8dfc81be-7461-48f2-8caf-07402bccb0ea.
        /// </summary>
        public static string P_RODCRevealOnDemand_Documentation {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one privileged group can be revealed on RODC.
        /// </summary>
        public static string P_RODCRevealOnDemand_Rationale {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_RODCRevealOnDemand_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the attribute msDS-RevealOnDemandGroup and remove the privileged user or group identified.
        ///    
        ///    This can be managed in the Password Replication Policy tab of the computer object in the Active Directory Users and Computers console..
        /// </summary>
        public static string P_RODCRevealOnDemand_Solution {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to There is an attribute on each RODC which enumerates the groups that the RODC can retrieve.
        ///    When the RODC retrieve the user account, all secrets are integrated into the data, meaning that the RODC can impersonate the user account.
        ///  In this case, a user or a group has been identified that have a RID (the last part of the SID) lower than 1000.
        ///All privileged groups have a RID lower than 1000, than means that the RODC can get access at any time to that privileged information..
        /// </summary>
        public static string P_RODCRevealOnDemand_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if a privileged group can be revealed on a RODC.
        /// </summary>
        public static string P_RODCRevealOnDemand_Title {
            get {
                return ResourceManager.GetString("P_RODCRevealOnDemand_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no RODC has write access to the SYSVOL.
        /// </summary>
        public static string P_RODCSYSVOLWrite_Description {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string P_RODCSYSVOLWrite_Detail {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-frs2/3588b343-4076-4776-b5c0-78e2b3d91ed3.
        /// </summary>
        public static string P_RODCSYSVOLWrite_Documentation {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one RODC has write access to the SYSVOL volume.
        /// </summary>
        public static string P_RODCSYSVOLWrite_Rationale {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string P_RODCSYSVOLWrite_ReportLocation {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the domain controller object related to the RODC in ADSIEdit.
        ///    Then zoom on CN=DFSR-LocalSettings then CN=Domain System Volume.
        ///    Edit the attribute msDFSR-ReadOnly and change it from false to true.
        ///    .
        /// </summary>
        public static string P_RODCSYSVOLWrite_Solution {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SYSVOL Volume is a special DFS volume used to store system files such as GPO.
        ///    Read Only Domain Controllers (RODC) have read-only access to it.
        ///  If it has write access, it can change the file locally and propagate them to all writable domain controllers.
        ///And thus enable an attacker to take control of the domain by modifying a GPO applied to Domain Controllers..
        /// </summary>
        public static string P_RODCSYSVOLWrite_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if RODCs have write access to the SYSVOL volume.
        /// </summary>
        public static string P_RODCSYSVOLWrite_Title {
            get {
                return ResourceManager.GetString("P_RODCSYSVOLWrite_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no account can make unexpected modifications to the schema.
        /// </summary>
        public static string P_SchemaAdmin_Description {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_SchemaAdmin_Documentation {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The group Schema Admins is not empty: {count} account(s).
        /// </summary>
        public static string P_SchemaAdmin_Rationale {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_SchemaAdmin_ReportLocation {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the accounts or groups belonging to the &quot;schema administrators&quot; group..
        /// </summary>
        public static string P_SchemaAdmin_Solution {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The group &quot;Schema Admins&quot; is used to give permissions to alter the schema. Once a modification is performed on the schema such as new objects, it cannot be undone. This can result in a rebuild of the domain. The best practice is to have this group empty and to add an administrator when a schema update is required, then remove this group membership..
        /// </summary>
        public static string P_SchemaAdmin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unexpected schema modifications which could result in domain rebuild.
        /// </summary>
        public static string P_SchemaAdmin_Title {
            get {
                return ResourceManager.GetString("P_SchemaAdmin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check for accounts with non-expiring passwords in the &quot;Domain Administrator&quot; group.
        /// </summary>
        public static string P_ServiceDomainAdmin_Description {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string P_ServiceDomainAdmin_Detail {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_ServiceDomainAdmin_Documentation {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of accounts with non-expiring passwords in the domain admin group (at least {threshold} accounts): {count}.
        /// </summary>
        public static string P_ServiceDomainAdmin_Rationale {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admingroups&quot;&gt;Admin Groups&lt;/a&gt;.
        /// </summary>
        public static string P_ServiceDomainAdmin_ReportLocation {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Accounts with never expiring passwords are mostly service accounts. 
        ///    To mitigate the security risk, it is strongly advised to lower the privileges of the &quot;Service Accounts&quot;, meaning that they should be removed from the &quot;Domain Administrator&quot; group, while ensuring that the password of each and every &quot;Service Account&quot; is longer than 20 characters.
        /// </summary>
        public static string P_ServiceDomainAdmin_Solution {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PingCastle is checking accounts with never expiring password, that are mostly used as service accounts.
        ///    &quot;Service Accounts&quot; can imply a high security risk as their password are stored in clear text in the LSA database, which can then be easily exploited using Mimikatz or Cain&amp;Abel for instance. In addition, their passwords don&apos;t change and can be used in Kerberoast attacks..
        /// </summary>
        public static string P_ServiceDomainAdmin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if Service Accounts (aka accounts with never expiring password) are domain administrators.
        /// </summary>
        public static string P_ServiceDomainAdmin_Title {
            get {
                return ResourceManager.GetString("P_ServiceDomainAdmin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no assignment of the SeTrustedCredManAccessPrivilege privilege..
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Description {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} User: {1}.
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Detail {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/win32/secauthn/credentials-management
        ///https://github.com/daem0nc0re/PrivFu#privilegedoperations
        ///https://github.com/daem0nc0re/PrivFu/blob/main/PrivilegedOperations/SeTrustedCredManAccessPrivilegePoC/SeTrustedCredManAccessPrivilegePoC.cs.
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Documentation {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The privilege &quot;Access Credential Manager as a trusted caller user right&quot; has been explicitly granted..
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Rationale {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpoprivileges&quot;&gt;Privileges&lt;/a&gt;.
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_ReportLocation {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should edit the GPO and remove the GPO right assignment.
        ///    
        ///The setting is located in Computer Policy -&gt; Computer Configuration -&gt; Windows Settings -&gt; Security Settings -&gt; Local Policies -&gt; User Rights Assignment..
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Solution {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Credential Manger is a vault where credentials are being stored.
        ///This privilege can be used to retrieve the secret data.
        ///
        ///A POC to exploit this privilege is available in the documents linked below.
        ///    .
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if there is the privilege &quot;Access Credential Manager&quot; has been explicitly granted to a user other than the &quot;Winlogon service&quot;..
        /// </summary>
        public static string P_TrustedCredManAccessPrivilege_Title {
            get {
                return ResourceManager.GetString("P_TrustedCredManAccessPrivilege_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule identifies accounts configured with Kerberos unconstrained delegation, a high-risk setting that allows a compromised service to impersonate any domain user and potentially lead to full domain compromise..
        /// </summary>
        public static string P_UnconstrainedDelegation_Description {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} Name: {1}.
        /// </summary>
        public static string P_UnconstrainedDelegation_Detail {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/blogs/389thoughts/get-rid-of-accounts-that-use-kerberos-unconstrained-delegation
        ///https://adsecurity.org/?p=1667.
        /// </summary>
        public static string P_UnconstrainedDelegation_Documentation {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unconstrained delegations are configured on the domain: {count} account(s).
        /// </summary>
        public static string P_UnconstrainedDelegation_Rationale {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string P_UnconstrainedDelegation_ReportLocation {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos unconstrained delegation should be removed wherever it is configured. If delegation is required, it must be replaced with &lt;b&gt;Kerberos constrained delegation&lt;/b&gt;.
        ///
        ///    &lt;b&gt;Step 1: Remove Unconstrained Delegation&lt;/b&gt;
        ///    Remove the ability for the account to delegate credentials to any service.
        ///
        ///    &lt;b&gt;Computer accounts&lt;/b&gt;
        ///    &lt;i&gt;Set-ADComputer -Identity &lt;ComputerName&gt; -TrustedForDelegation $false&lt;/i&gt;
        ///
        ///    &lt;b&gt;User accounts&lt;/b&gt;
        ///    &lt;i&gt;Set-ADUser -Identity &lt;UserName&gt; -TrustedForDelegation $fal [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_UnconstrainedDelegation_Solution {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos unconstrained delegation allows a service to reuse a user’s Ticket Granting Ticket (TGT) to authenticate to any service in the domain. If the delegated account is compromised, cached TGTs can be extracted and used to impersonate any authenticating user.
        ///        If a privileged account or a Domain Controller authenticates to such a service, potentially via forced authentication techniques, the attacker can escalate privileges and compromise the entire domain. Disabling the account does not remove t [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_UnconstrainedDelegation_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that no accounts are subject to unconstrained delegation.
        /// </summary>
        public static string P_UnconstrainedDelegation_Title {
            get {
                return ResourceManager.GetString("P_UnconstrainedDelegation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify that each delegation is linked to an account which exists.
        /// </summary>
        public static string P_UnkownDelegation_Description {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0} delegation: {1} right: {2}.
        /// </summary>
        public static string P_UnkownDelegation_Detail {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string P_UnkownDelegation_Documentation {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of unknown account in delegation: {count}.
        /// </summary>
        public static string P_UnkownDelegation_Rationale {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_UnkownDelegation_ReportLocation {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To reduce the risk, the easiest way is essentially to remove the delegation.
        /// </summary>
        public static string P_UnkownDelegation_Solution {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In the case where a delegation has been created, where the account can&apos;t be translated to a NT account, it means that the delegation is actually from another domain or that the user has been deleted. .
        /// </summary>
        public static string P_UnkownDelegation_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check delegations for the recipient&apos;s existence.
        /// </summary>
        public static string P_UnkownDelegation_Title {
            get {
                return ResourceManager.GetString("P_UnkownDelegation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that Organizational Units (OUs) and Containers in Active Directory are protected to prevent accidental deletion, which could lead to data loss and disruptions in the network infrastructure..
        /// </summary>
        public static string P_UnprotectedOU_Description {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to OU: {0}.
        /// </summary>
        public static string P_UnprotectedOU_Detail {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://dirteam.com/sander/2011/07/13/preventing-ous-and-containers-from-accidental-deletion/.
        /// </summary>
        public static string P_UnprotectedOU_Documentation {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to OU without the accidental deletion protection have been found.
        /// </summary>
        public static string P_UnprotectedOU_Rationale {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#admindelegation&quot;&gt;Delegations&lt;/a&gt;.
        /// </summary>
        public static string P_UnprotectedOU_ReportLocation {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To safeguard against accidental deletions, it is essential to enable the &quot;Protect object from accidental deletion&quot; option for critical OUs and Containers.
        ///    When this option is enabled, it adds an additional layer of security, preventing unintended deletions.
        ///  To implement this protection:
        ///
        ///* Open the Active Directory Users and Computers management console.
        ///* Locate the OU or Container that requires protection.
        ///* Right-click on the OU or Container, select &quot;Properties.&quot;
        ///* In the &quot;Object&quot; tab, check [rest of string was truncated]&quot;;.
        /// </summary>
        public static string P_UnprotectedOU_Solution {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In Active Directory, Organizational Units can be protected from accidental deletion (reads: using the del key in the wrong place at the wrong time).
        ///    This way these objects cannot be deleted, unless the protection is removed. This Active Directory feature was first introduced in Windows Server 2008.
        ///    
        ///    This protection consists of a Deny ACE added to the NTSecurityDescriptor attribute applied to Everyone with the flag set to Delete and DeleteTree.
        ///    .
        /// </summary>
        public static string P_UnprotectedOU_TechnicalExplanation {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if OUs and Containers are protected from accidental deletion..
        /// </summary>
        public static string P_UnprotectedOU_Title {
            get {
                return ResourceManager.GetString("P_UnprotectedOU_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the password is a secret, which protects its derivatives, such as the fingerprint named hash, it can be used as if it was the password itself..
        /// </summary>
        public static string PassTheCredential_Detail {
            get {
                return ResourceManager.GetString("PassTheCredential_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Passwords stored in clear text or obfuscated can be retrieved. By reusing the user&apos;s identity, an attacker&apos;s login appears like from any legitimate user. There&apos;s no need to perform a potentially detectable exploit for intrusion or lateral movement..
        /// </summary>
        public static string PasswordRetrieval_Detail {
            get {
                return ResourceManager.GetString("PasswordRetrieval_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Privileges are granted to special groups to perform their duty. Sometimes, these privileges can be used to take control of the domain..
        /// </summary>
        public static string PrivilegeControl_Detail {
            get {
                return ResourceManager.GetString("PrivilegeControl_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is important to control who can create new objects in the Active Directory. Indeed, its owner may introduce an object in which it has a strong control..
        /// </summary>
        public static string Provisioning_Detail {
            get {
                return ResourceManager.GetString("Provisioning_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At the beginning of an attack, a hacker tries to collect as much data as possible. Leaking information just reduces the time an attacker needs to gain control of the domain..
        /// </summary>
        public static string Reconnaissance_Detail {
            get {
                return ResourceManager.GetString("Reconnaissance_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Active Directory uses a distributed architecture to have a high-level of availability. This architecture replicates each change at a regular interval. Collision of changes can create unexpected objects which can be used later..
        /// </summary>
        public static string Replication_Detail {
            get {
                return ResourceManager.GetString("Replication_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Read-Only Domain Controllers are used in poor physically secured zones. An incorrect protection level can leak sensitive data..
        /// </summary>
        public static string RODC_Detail {
            get {
                return ResourceManager.GetString("RODC_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that basic users cannot register extra computers in the domain.
        /// </summary>
        public static string S_ADRegistration_Description {
            get {
                return ResourceManager.GetString("S_ADRegistration_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Owner: {1}.
        /// </summary>
        public static string S_ADRegistration_Detail {
            get {
                return ResourceManager.GetString("S_ADRegistration_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/troubleshoot/windows-server/identity/default-workstation-numbers-join-domain
        ///http://prajwaldesai.com/allow-domain-user-to-add-computer-to-domain/
        ///http://blog.backslasher.net/preventing-users-from-adding-computers-to-a-domain.html.
        /// </summary>
        public static string S_ADRegistration_Documentation {
            get {
                return ResourceManager.GetString("S_ADRegistration_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-admin users can add up to {count} computer(s) to a domain.
        /// </summary>
        public static string S_ADRegistration_Rationale {
            get {
                return ResourceManager.GetString("S_ADRegistration_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Threat Manager| monitors and optionally blocks unauthorized changes to domain policies, ensuring the security of computer account registrations and preventing privilege misuse.\r\nNetwrix Privilege Secure| helps dynamically assign permissions for machine additions only when required, removing persistent rights and reducing risk.\r\nNetwrix Directory Manager| enables delegated management of computer accounts with least privilege controls, ensuring proper oversight of domain join operations..
        /// </summary>
        public static string S_ADRegistration_RelevantProducts {
            get {
                return ResourceManager.GetString("S_ADRegistration_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the issue, limit the number of extra computers that can be registered by a basic user.  It can be reduced by modifying the value of &lt;i&gt;ms-DS-MachineAccountQuota&lt;/i&gt; to zero (0). Another solution can be to remove the &quot;Authenticated Users&quot; group in the domain controllers policy altogether. Do note, that if you need to set delegation to an account, so it can add computers to the domain, it can be done through 2 methods: Delegation in the OU or by assigning the &lt;i&gt;SeMachineAccountPrivilege&lt;/i&gt; to a spe [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_ADRegistration_Solution {
            get {
                return ResourceManager.GetString("S_ADRegistration_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, a basic user can register up to 10 computers within the domain. This default configuration represents a security issue as basic users shouldn&apos;t be able to create such accounts and this task should be handled by administrators.
        ///    
        ///    If the value of the attribute ms-DS-MachineAccountQuota is not set (the program see this as &quot;Infinite&quot;), there is no limit to computer addition.
        ///    
        ///    Note: this program checks also the GPO for SeMachineAccountPrivilege assignment. This assignment can be us [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_ADRegistration_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_ADRegistration_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the process of registration of computers to the domain.
        /// </summary>
        public static string S_ADRegistration_Title {
            get {
                return ResourceManager.GetString("S_ADRegistration_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that no schema class can be used to create arbitrary objects.
        /// </summary>
        public static string S_ADRegistrationSchema_Description {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Class: {0}  Vulnerability: {1}.
        /// </summary>
        public static string S_ADRegistrationSchema_Detail {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://bugs.chromium.org/p/project-zero/issues/detail?id=2186
        ///https://gist.github.com/IISResetMe/399a75cfccabc1a17d0cc3b5ae29f3aa#file-update-msexchstoragegroupschema-ps1
        ///https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34470.
        /// </summary>
        public static string S_ADRegistrationSchema_Documentation {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of vulnerable schema class = {count}.
        /// </summary>
        public static string S_ADRegistrationSchema_Rationale {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_ADRegistrationSchema_ReportLocation {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to For PossSuperiorComputer:
        ///    You have to edit the schema to change the value of the attribute possSuperior and remove the &quot;computer&quot; value.
        ///  A PowerShell script in the documentation provides a fix.
        ///
        ///For PossSuperiorUser:
        ///    You have to edit the schema to change the value of the attribute possSuperior and remove the &quot;user&quot; value.
        ///  A PowerShell script in the documentation provides a fix.
        ///  
        ///Also the class msExchStorageGroup is known to have this vulnerability via the CVE-2021-34470.
        ///In this case, [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_ADRegistrationSchema_Solution {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The classes added to the schema provide additional object types. If misconfigured, a class can be used to bypass a security restriction.
        ///    For the vulnerability PossSuperiorComputer:
        ///    A class has the attribute possSuperiors containing the class &quot;computer&quot; and this class inherits from &quot;container&quot;.
        ///  That means that every computer can request this class to be added.
        ///  Once this class has been added, it can be used as a container to create additional users or computers without restrictions.
        ///
        ///    For [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_ADRegistrationSchema_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Vulnerable Schema Class check.
        /// </summary>
        public static string S_ADRegistrationSchema_Title {
            get {
                return ResourceManager.GetString("S_ADRegistrationSchema_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify that AES is enabled for service accounts..
        /// </summary>
        public static string S_AesNotEnabled_Description {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/blogs/openspecification/msds-supportedencryptiontypes-episode-1-computer-accounts.
        /// </summary>
        public static string S_AesNotEnabled_Documentation {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of service accounts without AES support = {count}.
        /// </summary>
        public static string S_AesNotEnabled_Rationale {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_AesNotEnabled_ReportLocation {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is recommended to enable AES as an encryption algorithm in the user configuration dialog or in the &quot;msDSSupportedEncryptionTypes&quot; attribute at LDAP level. 
        ///    It has to be enabled in the property of an account by checking all the boxes &quot;This account supports Keberos AES XXX encryption&quot;.
        ///  
        ///    For GMSA account, you have to manually edit the property msDS-SupportedEncryptionTypes.
        /// </summary>
        public static string S_AesNotEnabled_Solution {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The default encryption algorithm used by Kerberos is RC4, which directly utilizes the NTLM hash of the user’s password.
        ///    However, due to the rapid advancements in computing power, it’s recommended to transition from RC4 to the more secure AES algorithm.
        ///    
        /// Before disabling RC4, the first step is to enable AES.
        /// It’s important to note that service accounts and user accounts with the ‘serviceprincipalname’ attribute (also known as SPN) need to be configured to support AES. 
        /// Without this configurat [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_AesNotEnabled_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the use of Kerberos on services accounts without AES support.
        /// </summary>
        public static string S_AesNotEnabled_Title {
            get {
                return ResourceManager.GetString("S_AesNotEnabled_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there are as few inactive computers as possible within the domain..
        /// </summary>
        public static string S_C_Inactive_Description {
            get {
                return ResourceManager.GetString("S_C_Inactive_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_C_Inactive_Documentation {
            get {
                return ResourceManager.GetString("S_C_Inactive_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Relatively high number of inactive computer accounts: {count}% (more than {threshold}% of all computers).
        /// </summary>
        public static string S_C_Inactive_Rationale {
            get {
                return ResourceManager.GetString("S_C_Inactive_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Access Analyzer| helps remediate inactive computers in bulk and at scale. It enables you to identify stale users and computers and automate their disablement, relocation, or deletion through integrated workflows—ensuring a streamlined and secure Active Directory cleanup process..
        /// </summary>
        public static string S_C_Inactive_RelevantProducts {
            get {
                return ResourceManager.GetString("S_C_Inactive_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To mitigate the risk, you should monitor the number of inactive accounts and reduce it as much as possible. A list of all inactive accounts is obtainable through the command: &lt;i&gt;Search-ADAccount –AccountInActive –ComputersOnly –TimeSpan 180:00:00:00 –ResultPageSize 2000 –ResultSetSize $null | ?{$_.Enabled –eq $True} | Select-Object Name, SamAccountName, DistinguishedName&lt;/i&gt;..
        /// </summary>
        public static string S_C_Inactive_Solution {
            get {
                return ResourceManager.GetString("S_C_Inactive_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inactive computers often stay in the network because of weaknesses in the decommissioning process. These stale computer accounts can be used as backdoors and therefore represents a possible security breach. .
        /// </summary>
        public static string S_C_Inactive_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_C_Inactive_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inactive computer check.
        /// </summary>
        public static string S_C_Inactive_Title {
            get {
                return ResourceManager.GetString("S_C_Inactive_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check for unusual value in the primarygroupid attribute used to store group membership.
        /// </summary>
        public static string S_C_PrimaryGroup_Description {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_C_PrimaryGroup_Documentation {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of wrong primary group for computers: {count}.
        /// </summary>
        public static string S_C_PrimaryGroup_Rationale {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Auditor| monitors and alerts on changes to group memberships in Active Directory, with a complete audit trail for accountability. \r\nNetwrix Threat Manager| monitors and alerts on unauthorized changes to group memberships, with the option to block them, preventing privilege escalation.\r\nNetwrix Access Analyzer| detects hidden group memberships for user accounts and can remediate security risks by removing computer accounts from groups in bulk..
        /// </summary>
        public static string S_C_PrimaryGroup_RelevantProducts {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_C_PrimaryGroup_ReportLocation {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unless strongly justified, change the primary group id to its default: 513 or 514 for users, 516 or 521 for domain controllers, 514 or 515 for computers. The primary group can be edited in a friendly manner by editing the account with the &quot;Active Directory Users and Computers&quot; and after selecting the &quot;Member Of&quot; tab, &quot;set primary group&quot;..
        /// </summary>
        public static string S_C_PrimaryGroup_Solution {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In Active Directory, group membership is stored on the &quot;members&quot; attribute and on the &quot;primarygroupid&quot; attribute.
        ///    The default primary group value is &quot;Domain Users&quot; for the users, &quot;Domain Computers&quot; for the computers and &quot;Domain Controllers&quot; for the domain controllers.
        ///    The primarygroupid contains the RID (last digits of a SID) of the group targeted. It can be used to store hidden membership as this attribute is not often analyzed.
        ///    This rule can also be triggered if one domain controller is not [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_C_PrimaryGroup_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for hidden group membership for computer accounts.
        /// </summary>
        public static string S_C_PrimaryGroup_Title {
            get {
                return ResourceManager.GetString("S_C_PrimaryGroup_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if there are accounts currently running with a reversible password.
        /// </summary>
        public static string S_C_Reversible_Description {
            get {
                return ResourceManager.GetString("S_C_Reversible_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_C_Reversible_Documentation {
            get {
                return ResourceManager.GetString("S_C_Reversible_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of computers which have a reversible password: {count}.
        /// </summary>
        public static string S_C_Reversible_Rationale {
            get {
                return ResourceManager.GetString("S_C_Reversible_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_C_Reversible_ReportLocation {
            get {
                return ResourceManager.GetString("S_C_Reversible_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To remove this risk, there should be no account(s) with reversible encryption for the password. You should remove them by removing the flag &quot;Store password using reversible encryption&quot; on all accounts, so that the cleartext password is removed at the next password change. You can get a list of all the possibly compromised accounts running the following PowerShell command: &lt;i&gt;get-adobject -ldapfilter &quot;(userAccountControl:1.2.840.113556.1.4.803:=128)&quot; -properties useraccountcontrol&lt;/i&gt;.
        /// </summary>
        public static string S_C_Reversible_Solution {
            get {
                return ResourceManager.GetString("S_C_Reversible_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is possible that domains have accounts with an encryption that can be reversed. In this case, it means that the password is actually stored in clear text in the &lt;i&gt;supplementalCredential&lt;/i&gt; attribute of the account and that it can be retrieved using a DCSync attack.
        /// </summary>
        public static string S_C_Reversible_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_C_Reversible_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for reversible passwords used for computer accounts.
        /// </summary>
        public static string S_C_Reversible_Title {
            get {
                return ResourceManager.GetString("S_C_Reversible_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows 2000 as Domain Controller within the domain.
        /// </summary>
        public static string S_DC_2000_Description {
            get {
                return ResourceManager.GetString("S_DC_2000_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_DC_2000_Documentation {
            get {
                return ResourceManager.GetString("S_DC_2000_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows 2000 as DC = {count}.
        /// </summary>
        public static string S_DC_2000_Rationale {
            get {
                return ResourceManager.GetString("S_DC_2000_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The operating system of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_2000_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_2000_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To resolve this security risk, the only way is to decommission DC running Windows 2000 OS, in order to use new versions that are more secured and that are still being patched regarding new security threats.
        /// </summary>
        public static string S_DC_2000_Solution {
            get {
                return ResourceManager.GetString("S_DC_2000_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The OS Windows 2000 as a DC is vulnerable to many publicly known exploits such as MS17-010 or MS14-068 and it can no longer be patched. A domain running this OS version should be considered compromised.
        /// </summary>
        public static string S_DC_2000_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_2000_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete Domain Controller (Windows 2000).
        /// </summary>
        public static string S_DC_2000_Title {
            get {
                return ResourceManager.GetString("S_DC_2000_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2003 as Domain Controller within the domain.
        /// </summary>
        public static string S_DC_2003_Description {
            get {
                return ResourceManager.GetString("S_DC_2003_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_DC_2003_Documentation {
            get {
                return ResourceManager.GetString("S_DC_2003_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2003 as DC = {count}.
        /// </summary>
        public static string S_DC_2003_Rationale {
            get {
                return ResourceManager.GetString("S_DC_2003_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The operating system of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_2003_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_2003_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To resolve this security risk, the only way is to decommission DC running Windows Server 2003 OS, in order to use new versions that are more secured and that are still being patched regarding new security threats.
        /// </summary>
        public static string S_DC_2003_Solution {
            get {
                return ResourceManager.GetString("S_DC_2003_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The OS Windows Server 2003 as a DC is vulnerable to many publicly known exploits such as MS14-068 and it is very complicated to patch it at this date. A domain running this OS version should be considered compromised.
        /// </summary>
        public static string S_DC_2003_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_2003_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete Domain Controller (Windows Server 2003).
        /// </summary>
        public static string S_DC_2003_Title {
            get {
                return ResourceManager.GetString("S_DC_2003_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2008 as Domain Controller within the domain.
        /// </summary>
        public static string S_DC_2008_Description {
            get {
                return ResourceManager.GetString("S_DC_2008_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-server-eos-faq/end-of-support-windows-server-2008-2008r2.
        /// </summary>
        public static string S_DC_2008_Documentation {
            get {
                return ResourceManager.GetString("S_DC_2008_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2008 as DC = {count}.
        /// </summary>
        public static string S_DC_2008_Rationale {
            get {
                return ResourceManager.GetString("S_DC_2008_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The operating system of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_2008_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_2008_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To resolve this security risk, the only way is to decommission DCs running Windows Server 2008 OS, in order to use new versions that are more secure and that are still being patched regarding new security threats.
        /// </summary>
        public static string S_DC_2008_Solution {
            get {
                return ResourceManager.GetString("S_DC_2008_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The OS Windows Server 2008 is not supported anymore by Microsoft (except when migrated to Azure, until January 9, 2024) and any vulnerability found will not be patched..
        /// </summary>
        public static string S_DC_2008_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_2008_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete Domain Controller (Windows Server 2008).
        /// </summary>
        public static string S_DC_2008_Title {
            get {
                return ResourceManager.GetString("S_DC_2008_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2012 as Domain Controller within the domain.
        /// </summary>
        public static string S_DC_2012_Description {
            get {
                return ResourceManager.GetString("S_DC_2012_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-US/lifecycle/products/windows-server-2012-r2.
        /// </summary>
        public static string S_DC_2012_Documentation {
            get {
                return ResourceManager.GetString("S_DC_2012_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2012 as DC = {count}.
        /// </summary>
        public static string S_DC_2012_Rationale {
            get {
                return ResourceManager.GetString("S_DC_2012_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The operating system of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_2012_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_2012_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To resolve this security risk, the only way is to decommission DCs running Windows Server 2012 OS, in order to use new versions that are more secure and that are still being patched regarding new security threats.
        /// </summary>
        public static string S_DC_2012_Solution {
            get {
                return ResourceManager.GetString("S_DC_2012_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The OS Windows Server 2012 is not supported anymore by Microsoft (except when migrated to Azure, until January 9, 2024) and any vulnerability found will not be patched..
        /// </summary>
        public static string S_DC_2012_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_2012_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete Domain Controller (Windows Server 2012).
        /// </summary>
        public static string S_DC_2012_Title {
            get {
                return ResourceManager.GetString("S_DC_2012_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that every DC is active..
        /// </summary>
        public static string S_DC_Inactive_Description {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string S_DC_Inactive_Detail {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/deploy/demoting-domain-controllers-and-domains--level-200-.
        /// </summary>
        public static string S_DC_Inactive_Documentation {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC inactive: {count}.
        /// </summary>
        public static string S_DC_Inactive_Rationale {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_Inactive_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_Inactive_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to demote the DC object using the procedure referenced in the documentation section.
        ///    .
        /// </summary>
        public static string S_DC_Inactive_Solution {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain Controllers are user accounts with powerful privileges.
        ///    While an active Domain Controller changes its password every 30 days, an inactive account can be involved in a domain compromise.
        ///    Indeed, another account, which has rights over this object, may reset the password of this account without being noticed.
        ///    .
        /// </summary>
        public static string S_DC_Inactive_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_Inactive_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC are active..
        /// </summary>
        public static string S_DC_Inactive_Title {
            get {
                return ResourceManager.GetString("S_DC_Inactive_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all the Domain Controllers are updated regularly. This is done by checking if a DC has been rebooted in the past 6 months. If not, it means it has not been patched as well in these 6 months.
        /// </summary>
        public static string S_DC_NotUpdated_Description {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Reason: {1}.
        /// </summary>
        public static string S_DC_NotUpdated_Detail {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_DC_NotUpdated_Documentation {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC not updated = {count}.
        /// </summary>
        public static string S_DC_NotUpdated_Rationale {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_NotUpdated_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Frequently updating the DC should be part of the AD policies, as there should be a dedicated time-slot for the servers to reboot and apply security patches.
        /// </summary>
        public static string S_DC_NotUpdated_Solution {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain Controller needs to be updated regularly because threats to the AD evolve all the time, so assets in the AD should evolve accordingly. The date of last update is computed by getting the &lt;i&gt;StatisticsStartTime&lt;/i&gt; from &lt;i&gt;[net statistics workstation]&lt;/i&gt;. If not available, the PingCastle solution will use the &lt;i&gt;lastLogonTimestamp&lt;/i&gt; attribute which is refreshed based on the LastLogon attribute. Do note that there is a maximum delay for refresh: 14 days..
        /// </summary>
        public static string S_DC_NotUpdated_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller update.
        /// </summary>
        public static string S_DC_NotUpdated_Title {
            get {
                return ResourceManager.GetString("S_DC_NotUpdated_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the minimum set of subnet(s) has been configured in the domain.
        /// </summary>
        public static string S_DC_SubnetMissing_Description {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} ip: {1}.
        /// </summary>
        public static string S_DC_SubnetMissing_Detail {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_DC_SubnetMissing_Documentation {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The subnet declaration is incomplete [{count} IP of DC not found in declared subnets].
        /// </summary>
        public static string S_DC_SubnetMissing_Rationale {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DC_SubnetMissing_ReportLocation {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locate the IP address which was found as not being part of declared subnet, then add this subnet to the &quot;Active Directory Sites&quot; tool. If you have found IPv6 addresses and it was not expected, you should disable the IPv6 protocol on the network card..
        /// </summary>
        public static string S_DC_SubnetMissing_Solution {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When multiple sites are created in a domain, networks should be declared in the domain in order to optimize processes such as DC attribution. In addition, PingCastle can collect the information to be able to build a network map. This rule has been triggered because at least one domain controller has an IP address which was not found in subnet declaration. These IP addresses have been collected by querying the DC FQDN IP address in both IPv6 and IPv4 format..
        /// </summary>
        public static string S_DC_SubnetMissing_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for completeness of network declaration.
        /// </summary>
        public static string S_DC_SubnetMissing_Title {
            get {
                return ResourceManager.GetString("S_DC_SubnetMissing_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that DC are well registered..
        /// </summary>
        public static string S_DCRegistration_Description {
            get {
                return ResourceManager.GetString("S_DCRegistration_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Problem: {1}.
        /// </summary>
        public static string S_DCRegistration_Detail {
            get {
                return ResourceManager.GetString("S_DCRegistration_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/9164e4e8-f892-4ca2-8067-059f6f9387a4
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/8ebf2419-1169-4413-88e2-12a5ad499cf5.
        /// </summary>
        public static string S_DCRegistration_Documentation {
            get {
                return ResourceManager.GetString("S_DCRegistration_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC with a configuration issue: {count}.
        /// </summary>
        public static string S_DCRegistration_Rationale {
            get {
                return ResourceManager.GetString("S_DCRegistration_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_DCRegistration_ReportLocation {
            get {
                return ResourceManager.GetString("S_DCRegistration_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule result is either the result of a manual or software based misconfiguration. It can also be the sign of a compromise.
        ///      Depending on the anonamly reported, you have to perform the following actions:
        ///      - for InvalidUserAccount:
        ///      you have to check that the userAccountControl attribute of the AD object is either 0x00082000 for RW DC or 0x05001000 for RODC
        ///      - for NoConfiguration:
        ///      the DC registration in the Configuration partition is mising. The DC should not be active and n [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_DCRegistration_Solution {
            get {
                return ResourceManager.GetString("S_DCRegistration_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To be registered as a domain controller, a computer must be a member of the domain controller group, but also has some specific settings.
        ///The settings are a change of the userAccountControl attribute and a couple of objects in the configuration partition.
        ///This rule is triggered when an inconsistency has been detected between the expected values and the real values.
        ///
        ///The user account control value for Read/Write DC is:
        ///SERVER_TRUST_ACCOUNT (0x00002000) | TRUSTED_FOR_DELEGATION (0x00080000) = 0x00082000        /// [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_DCRegistration_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DCRegistration_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC are well registered..
        /// </summary>
        public static string S_DCRegistration_Title {
            get {
                return ResourceManager.GetString("S_DCRegistration_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the default location of computers and user OU has not been changed..
        /// </summary>
        public static string S_DefaultOUChanged_Description {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expected: {0} Found: {1}.
        /// </summary>
        public static string S_DefaultOUChanged_Detail {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/5a00c890-6be5-4575-93c4-8bf8be0ca8d8
        ///https://rickardnobel.se/verify-redirected-computers-container-in-active-directory/.
        /// </summary>
        public static string S_DefaultOUChanged_Documentation {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one default of default OU has been changed.
        /// </summary>
        public static string S_DefaultOUChanged_Rationale {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_DefaultOUChanged_ReportLocation {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to use redircmp to set the value back to normal. See documentation for more details
        ///  .
        /// </summary>
        public static string S_DefaultOUChanged_Solution {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Default OU such as CN=Computers or CN=Users are stored within the wellKnownObjects attribute of the Domain object.
        ///    There are 12 default locations officialy defined.
        ///    They can be changed using the program redircmp.
        ///    Changing these default can alter the behavior of programs (such as security audit programs) as they may not check the modified objects.
        ///    .
        /// </summary>
        public static string S_DefaultOUChanged_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if default OU location has been changed within the domain..
        /// </summary>
        public static string S_DefaultOUChanged_Title {
            get {
                return ResourceManager.GetString("S_DefaultOUChanged_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule confirms the activation of Defender ASR (Attack Surface Reduction) mitigations within a Group Policy Object (GPO)..
        /// </summary>
        public static string S_DefenderASR_Description {
            get {
                return ResourceManager.GetString("S_DefenderASR_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Guid: {0} Label: {1} Reason: {2}.
        /// </summary>
        public static string S_DefenderASR_Detail {
            get {
                return ResourceManager.GetString("S_DefenderASR_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/defender-endpoint/attack-surface-reduction-rules-reference?view=o365-worldwide#per-asr-rule-alert-and-notification-details
        ///https://blog.palantir.com/microsoft-defender-attack-surface-reduction-recommendations-a5c7d41c3cf8.
        /// </summary>
        public static string S_DefenderASR_Documentation {
            get {
                return ResourceManager.GetString("S_DefenderASR_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Not all possible Defender ASR mitigations are in Block or Warn mode.
        /// </summary>
        public static string S_DefenderASR_Rationale {
            get {
                return ResourceManager.GetString("S_DefenderASR_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpodefenderASR&quot;&gt;Defender ASR&lt;/a&gt;.
        /// </summary>
        public static string S_DefenderASR_ReportLocation {
            get {
                return ResourceManager.GetString("S_DefenderASR_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To apply an ASR mitigation, navigate to the GPO setting &quot;Configure Attack Surface Reduction rules&quot; found under Computer Configuration &gt; Policies &gt; Administrative Templates &gt; Windows Components &gt; Microsoft Defender Antivirus (formerly Windows Defender Antivirus) &gt; Microsoft (Windows) Defender Exploit Guard &gt; Attack Surface Reduction.
        ///    Upon enabling this setting, select &quot;Set the state for each ASR rule&quot;.
        ///    Then, input the mitigation’s GUID as the Value name and assign 1 as the Value to enforce the rule [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_DefenderASR_Solution {
            get {
                return ResourceManager.GetString("S_DefenderASR_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Microsoft Defender, the default antivirus included with Windows, activates automatically on systems without a pre-installed alternative.
        ///    Defender’s ASR features, designed to minimize vulnerability to attacks, are available even in the standard version.
        ///    These protections have been part of Windows since the release of Windows 10 version 1710 and are also applicable to Windows Server 2012 R2.
        ///	
        ///  Note: Windows 11 may enable in some conditions those 3 ASR rules: Block abuse of exploited vulnerable s [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_DefenderASR_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DefenderASR_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify that Defender ASR mitigations are in place.
        /// </summary>
        public static string S_DefenderASR_Title {
            get {
                return ResourceManager.GetString("S_DefenderASR_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify that no weak encryption algorithm such as DES is used for accounts..
        /// </summary>
        public static string S_DesEnabled_Description {
            get {
                return ResourceManager.GetString("S_DesEnabled_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string S_DesEnabled_Detail {
            get {
                return ResourceManager.GetString("S_DesEnabled_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/archive/blogs/openspecification/msds-supportedencryptiontypes-episode-1-computer-accounts
        ///https://learn.microsoft.com/en-us/services-hub/unified/health/remediation-steps-ad/remove-the-highly-insecure-des-encryption-from-user-accounts.
        /// </summary>
        public static string S_DesEnabled_Documentation {
            get {
                return ResourceManager.GetString("S_DesEnabled_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of DES Enabled accounts = {count}.
        /// </summary>
        public static string S_DesEnabled_Rationale {
            get {
                return ResourceManager.GetString("S_DesEnabled_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_DesEnabled_ReportLocation {
            get {
                return ResourceManager.GetString("S_DesEnabled_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is recommended to disable DES as an encryption algorithm in the user configuration dialog or in the &quot;msDSSupportedEncryptionTypes&quot; attribute at LDAP level. It has to be disabled in the property of an account by unchecking the box &quot;Use Kerberos DES encryption for this account&quot;. You can also detect which accounts support Kerberos DES encryption by running: &lt;i&gt;Get-ADObject -Filter {UserAccountControl -band 0x200000 -or msDs-supportedEncryptionTypes -band 3}&lt;/i&gt;..
        /// </summary>
        public static string S_DesEnabled_Solution {
            get {
                return ResourceManager.GetString("S_DesEnabled_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DES is a very weak algorithm and once assigned to an account, it can be used in Kerberos ticket requests, even though it is easily cracked. If the attacker cracks the Kerberos ticket, they can steal the token and compromise the user account..
        /// </summary>
        public static string S_DesEnabled_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_DesEnabled_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check the use of Kerberos with weak encryption (DES algorithm).
        /// </summary>
        public static string S_DesEnabled_Title {
            get {
                return ResourceManager.GetString("S_DesEnabled_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the SID History creation is not enabled.
        /// </summary>
        public static string S_Domain____Description {
            get {
                return ResourceManager.GetString("S_Domain____Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_Domain____Documentation {
            get {
                return ResourceManager.GetString("S_Domain____Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory auditing group is present: SID History creation is enabled.
        /// </summary>
        public static string S_Domain____Rationale {
            get {
                return ResourceManager.GetString("S_Domain____Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If a migration is in progress, declare it in PingCastle so this rule won&apos;t be triggered. Else, remove this auditing group. You can locate it by using the LDAP query (sAMAccountName=*$$$).
        /// </summary>
        public static string S_Domain____Solution {
            get {
                return ResourceManager.GetString("S_Domain____Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To migrate accounts to another domain, the attribute SID History should be added to the new account. Despite the fact that numerous hacking tools such as mimikatz allows the creation of the SID History attribute, its official creation requires the presence of a special auditing group named DOMAIN-$$$, for example TEST-$$$ for the TEST domain..
        /// </summary>
        public static string S_Domain____TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Domain____TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if a migration is in progress.
        /// </summary>
        public static string S_Domain____Title {
            get {
                return ResourceManager.GetString("S_Domain____Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if there are duplicate accounts within the domain. A duplicate account is essentially a duplicate of two objects having the same attributes..
        /// </summary>
        public static string S_Duplicate_Description {
            get {
                return ResourceManager.GetString("S_Duplicate_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_Duplicate_Documentation {
            get {
                return ResourceManager.GetString("S_Duplicate_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of duplicate accounts = {count}.
        /// </summary>
        public static string S_Duplicate_Rationale {
            get {
                return ResourceManager.GetString("S_Duplicate_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| prevents duplicate accounts by performing checks during provisioning or manual creation, ensuring a clean and efficient Active Directory environment. .
        /// </summary>
        public static string S_Duplicate_RelevantProducts {
            get {
                return ResourceManager.GetString("S_Duplicate_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_Duplicate_ReportLocation {
            get {
                return ResourceManager.GetString("S_Duplicate_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Duplicate accounts being present often means there are process failures, and they should be identified and removed. To identify all duplicate accounts, you can use the following PowerShell commands: &lt;i&gt;get-adobject -ldapfilter &quot;(cn=*cnf:*)&quot;&lt;/i&gt; ; &lt;i&gt;get-adobject -ldapfilter &quot;(sAMAccountName=$duplicate)&quot;&lt;/i&gt;.
        /// </summary>
        public static string S_Duplicate_Solution {
            get {
                return ResourceManager.GetString("S_Duplicate_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To identify a duplicate account, a check is performed on the &quot;DN&quot; and the &quot;sAMAccountName&quot;. When a DC detects a conflict, there is a replacement performed on the second object..
        /// </summary>
        public static string S_Duplicate_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Duplicate_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Duplicate account check.
        /// </summary>
        public static string S_Duplicate_Title {
            get {
                return ResourceManager.GetString("S_Duplicate_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies whether programs, such as script engines, are allowed to connect to the internet by default..
        /// </summary>
        public static string S_FirewallScript_Description {
            get {
                return ResourceManager.GetString("S_FirewallScript_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Program: {0} Reason: {1}.
        /// </summary>
        public static string S_FirewallScript_Detail {
            get {
                return ResourceManager.GetString("S_FirewallScript_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://medium.com/@cryps1s/endpoint-isolation-with-the-windows-firewall-462a795f4cfb.
        /// </summary>
        public static string S_FirewallScript_Documentation {
            get {
                return ResourceManager.GetString("S_FirewallScript_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is possible for scripts engine used by hackers to connect directly to the Internet.
        /// </summary>
        public static string S_FirewallScript_Rationale {
            get {
                return ResourceManager.GetString("S_FirewallScript_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpofirewall&quot;&gt;Firewall configuration&lt;/a&gt;.
        /// </summary>
        public static string S_FirewallScript_ReportLocation {
            get {
                return ResourceManager.GetString("S_FirewallScript_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 1) Create Firewall Rules via GPO
        ///    
        ///Configure the firewall rules under Computer Configuration / Policies / Windows Settings / Security Settings / Windows Defender Firewall with Advanced Security.
        ///Ensure the rules are applied on the Outbound side.
        ///Activate the rules.
        ///
        ///2) Network Restrictions:
        ///We recommend setting the rules as active for the following IP address ranges to allow local network access:
        ///0.0.0.0 to 9.255.255.255
        ///11.0.0.0 to 126.255.255.255
        ///128.0.0.1 to 172.15.255.255
        ///172.32.0.0 to 192 [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_FirewallScript_Solution {
            get {
                return ResourceManager.GetString("S_FirewallScript_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Malicious scripts, often distributed via phishing emails, frequently attempt to connect to the internet to propagate their infection.
        ///    To mitigate this risk, we recommend implementing a set of firewall rules through Group Policy Objects (GPOs).
        ///    These rules will prohibit direct internet connections for specific programs.
        ///    
        ///    The current list of programs to restrict includes: wscript.exe, mshta.exe, cscript.exe, conhost.exe, and runScriptHelper.exe.
        ///    .
        /// </summary>
        public static string S_FirewallScript_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_FirewallScript_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify if there are restrictions for internet connectivity of script engines.
        /// </summary>
        public static string S_FirewallScript_Title {
            get {
                return ResourceManager.GetString("S_FirewallScript_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The objective is to ensure scripts do not automatically execute upon opening by default..
        /// </summary>
        public static string S_FolderOptions_Description {
            get {
                return ResourceManager.GetString("S_FolderOptions_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extension: {0} Reason: {1}.
        /// </summary>
        public static string S_FolderOptions_Detail {
            get {
                return ResourceManager.GetString("S_FolderOptions_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://isc.sans.edu/diary/Controlling+JavaScript+Malware+Before+it+Runs/21171.
        /// </summary>
        public static string S_FolderOptions_Documentation {
            get {
                return ResourceManager.GetString("S_FolderOptions_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some script extensions, used in phishing, can be directly run by double clicking on it.
        /// </summary>
        public static string S_FolderOptions_Rationale {
            get {
                return ResourceManager.GetString("S_FolderOptions_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpofolderoptions&quot;&gt;Folder Options&lt;/a&gt;.
        /// </summary>
        public static string S_FolderOptions_ReportLocation {
            get {
                return ResourceManager.GetString("S_FolderOptions_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Navigate to Computer Configuration &gt; Preferences &gt; Control Panel Settings &gt; Folder Options.
        ///    Create a new File Type with the &quot;Replace&quot; action for the extension you wish to secure.
        ///    In &quot;Configure class settings&quot;, add a new &quot;open&quot; action with Notepad as the default application: C:\Windows\System32\notepad.exe.
        ///    .
        /// </summary>
        public static string S_FolderOptions_Solution {
            get {
                return ResourceManager.GetString("S_FolderOptions_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, PowerShell scripts (.ps1) open in Notepad, which blocks these extensions from being exploited in phishing attacks that evade email filters through multi-layered archives. 
        ///    However, several legacy script extensions (.js, .jse, .vbs, .vbe, .vb, .wsh, .wsf) still execute with their respective engines. 
        ///    While .js and .jse files are commonly associated with web content and handled by browsers, it’s crucial to recognize their potential for harm when executed directly in Windows.
        ///    Redirec [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_FolderOptions_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_FolderOptions_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify the Default Application for Script File Execution.
        /// </summary>
        public static string S_FolderOptions_Title {
            get {
                return ResourceManager.GetString("S_FolderOptions_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is checking the functional level of the domain and the forest, and ensure it is set to the latest secure version.
        /// </summary>
        public static string S_FunctionalLevel1_Description {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type: {0} Level: {1}.
        /// </summary>
        public static string S_FunctionalLevel1_Detail {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/active-directory-functional-levels
        ///https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/identifying-your-functional-level-upgrade
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/identity/raise-active-directory-domain-forest-functional-levels.
        /// </summary>
        public static string S_FunctionalLevel1_Documentation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional level is below Windows Server 2008 R2..
        /// </summary>
        public static string S_FunctionalLevel1_Rationale {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional levels are indicated in &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt;.
        /// </summary>
        public static string S_FunctionalLevel1_ReportLocation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to raise the functional level of the domain or the forest (see the details to know if the domain and/or forest is concerned).
        ///    The recommended level is the functional level 7 (Windows Server 2016 / 2019 / 2022)
        ///    
        ///    To upgrade the functional level, a requirement is that all domain controllers are running the right version.
        ///    Also, functional level needs to be upgraded level by level.
        ///    .
        /// </summary>
        public static string S_FunctionalLevel1_Solution {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///Each functional level brings new security features:
        ///*  functional level Windows Server 2003: brings forest trusts and read-only domain controller (RODC) support;
        ///*  functional level Windows Server 2008: brings support for modern cryptographic algorithms such as AES and DFS for SYSVOL shared replication;
        ///*  functional level Windows Server 2008R2: brings support for Active Directory Recycle Bin (protects objects against accidental deletion);
        ///*  functional level Windows Server 2012: brings advanced Kerbe [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_FunctionalLevel1_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the functional level of the domain and the forest are up to date to use the latest security features.
        /// </summary>
        public static string S_FunctionalLevel1_Title {
            get {
                return ResourceManager.GetString("S_FunctionalLevel1_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is checking the functional level of the domain and the forest, and ensure it is set to the latest secure version.
        /// </summary>
        public static string S_FunctionalLevel3_Description {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type: {0} Level: {1}.
        /// </summary>
        public static string S_FunctionalLevel3_Detail {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/active-directory-functional-levels
        ///https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/identifying-your-functional-level-upgrade
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/identity/raise-active-directory-domain-forest-functional-levels.
        /// </summary>
        public static string S_FunctionalLevel3_Documentation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional level is below Windows Server 2012 R2..
        /// </summary>
        public static string S_FunctionalLevel3_Rationale {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional levels are indicated in &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt;.
        /// </summary>
        public static string S_FunctionalLevel3_ReportLocation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to raise the functional level of the domain or the forest (see the details to know if the domain and/or forest is concerned).
        ///    The recommended level is the functional level 7 (Windows Server 2016 / 2019 / 2022)
        ///    
        ///    To upgrade the functional level, a requirement is that all domain controllers are running the right version.
        ///    Also, functional level needs to be upgraded level by level.
        ///    .
        /// </summary>
        public static string S_FunctionalLevel3_Solution {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///Each functional level brings new security features:
        ///*  functional level Windows Server 2003: brings forest trusts and read-only domain controller (RODC) support;
        ///*  functional level Windows Server 2008: brings support for modern cryptographic algorithms such as AES and DFS for SYSVOL share replication;
        ///*  functional level Windows Server 2008R2: brings support for Active Directory Recycle Bin (protects objects against accidental deletion);
        ///*  functional level Windows Server 2012: brings advanced Kerber [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_FunctionalLevel3_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the functional level of the domain and the forest are up to date to use the latest security features.
        /// </summary>
        public static string S_FunctionalLevel3_Title {
            get {
                return ResourceManager.GetString("S_FunctionalLevel3_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is checking the functional level of the domain and the forest, and ensure it is set to the latest secure version.
        /// </summary>
        public static string S_FunctionalLevel4_Description {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type: {0} Level: {1}.
        /// </summary>
        public static string S_FunctionalLevel4_Detail {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/active-directory-functional-levels
        ///https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/identifying-your-functional-level-upgrade
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-server/identity/raise-active-directory-domain-forest-functional-levels.
        /// </summary>
        public static string S_FunctionalLevel4_Documentation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional level is below Windows Server 2016..
        /// </summary>
        public static string S_FunctionalLevel4_Rationale {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The functional levels are indicated in &lt;a href=&quot;#domaininformation&quot;&gt;Domain Information&lt;/a&gt;.
        /// </summary>
        public static string S_FunctionalLevel4_ReportLocation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You have to raise the functional level of the domain or the forest (see the details to know if the domain and/or forest is concerned).
        ///    The recommended level is the functional level 7 (Windows Server 2016 / 2019 / 2022)
        ///    
        ///    To upgrade the functional level, a requirement is that all domain controllers are running the right version.
        ///    Also, functional level needs to be upgraded level by level.
        ///    .
        /// </summary>
        public static string S_FunctionalLevel4_Solution {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///Each functional level brings new security features:
        ///*  functional level Windows Server 2003: brings forest trusts and read-only domain controller (RODC) support;
        ///*  functional level Windows Server 2008: brings support for modern cryptographic algorithms such as AES and DFS for SYSVOL share replication;
        ///*  functional level Windows Server 2008R2: brings support for Active Directory Recycle Bin (protects objects against accidental deletion);
        ///*  functional level Windows Server 2012: brings advanced Kerber [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_FunctionalLevel4_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the functional level of the domain and the forest are up to date to use the latest security features.
        /// </summary>
        public static string S_FunctionalLevel4_Title {
            get {
                return ResourceManager.GetString("S_FunctionalLevel4_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there are as few inactive accounts as possible within the domain. Stale user accounts are a significant security issue, as former employees and external attackers could use those accounts to attack the organization..
        /// </summary>
        public static string S_Inactive_Description {
            get {
                return ResourceManager.GetString("S_Inactive_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_Inactive_Documentation {
            get {
                return ResourceManager.GetString("S_Inactive_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Relatively high number of inactive user accounts: {count}% (more than {threshold}% of all users).
        /// </summary>
        public static string S_Inactive_Rationale {
            get {
                return ResourceManager.GetString("S_Inactive_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| helps manage user and group lifecycles effectively, eliminating stale users and outdated group memberships.\r\n Netwrix Identity Manager| prevents stale users and memberships by automating identity lifecycle management and role-based provisioning or deprovisioning.\r\nNetwrix Privilege Secure| helps minimize stale secondary accounts with one-time ephemeral accounts, ensuring a clean and secure environment. .
        /// </summary>
        public static string S_Inactive_RelevantProducts {
            get {
                return ResourceManager.GetString("S_Inactive_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_Inactive_ReportLocation {
            get {
                return ResourceManager.GetString("S_Inactive_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To mitigate the risk, you should monitor the number of inactive accounts and reduce it as much as possible. A list of all inactive accounts is obtainable through the command: &lt;i&gt;Search-ADAccount –AccountInActive –UsersOnly –TimeSpan 180:00:00:00 –ResultPageSize 2000 –ResultSetSize $null | ?{$_.Enabled –eq $True} | Select-Object Name, SamAccountName, DistinguishedName&lt;/i&gt;..
        /// </summary>
        public static string S_Inactive_Solution {
            get {
                return ResourceManager.GetString("S_Inactive_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inactive accounts often stay in the network because of weaknesses in the decommissioning process. These stale computer accounts can be used as backdoors and therefore represents a possible security breach. .
        /// </summary>
        public static string S_Inactive_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Inactive_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inactive account check.
        /// </summary>
        public static string S_Inactive_Title {
            get {
                return ResourceManager.GetString("S_Inactive_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no Java schema extension.
        /// </summary>
        public static string S_JavaSchema_Description {
            get {
                return ResourceManager.GetString("S_JavaSchema_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_JavaSchema_Detail {
            get {
                return ResourceManager.GetString("S_JavaSchema_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf
        ///https://datatracker.ietf.org/doc/html/rfc2713
        ///https://docs.oracle.com/cd/E19424-01/820-4813/6ng8jv82s/index.html.
        /// </summary>
        public static string S_JavaSchema_Documentation {
            get {
                return ResourceManager.GetString("S_JavaSchema_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Java schema extension has been found.
        /// </summary>
        public static string S_JavaSchema_Rationale {
            get {
                return ResourceManager.GetString("S_JavaSchema_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#javacoderefence&quot;&gt;Java Code Reference&lt;/a&gt; section..
        /// </summary>
        public static string S_JavaSchema_ReportLocation {
            get {
                return ResourceManager.GetString("S_JavaSchema_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unfortuntaly there can be legit cases to use these Java attributes, that&apos;s why this rule is set to &quot;informative&quot; only.
        ///The recommended way to deal with this situation, is to either make sure that no objects are using these attributes, or to set the value com.sun.jndi.ldap.object.trustURLCodebase to &quot;false&quot; in ALL your Java code.
        ///PingCastle is displaying the active users having these Java attributes set in the Detail section.
        ///
        ///If you want to disable the Java extension you can proceed by setting each Java [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_JavaSchema_Solution {
            get {
                return ResourceManager.GetString("S_JavaSchema_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Log4shell vulnerability abused the fact that log4j could load objects via a special string containing JNDI load instructions.
        ///This load instruction refers to many protocols such as CORBA, DNS, ... but also LDAP.
        ///This rule checks if the RFC 2713 schema extension, which allows the representation of Java objects in the AD, has been applied.
        ///More precisely it checks if the schema contains the Java attributes javacodebase, javafactory, javaclassname, javaremotelocation or javaserializeddata.
        ///
        ///If the att [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_JavaSchema_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_JavaSchema_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search for Java schema extension RFC 2713.
        /// </summary>
        public static string S_JavaSchema_Title {
            get {
                return ResourceManager.GetString("S_JavaSchema_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that clients support Kerberos armoring when domain functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoring_Description {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_KerberosArmoring_Detail {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/hh831747(v=ws.11)
        ///    https://pupuweb.com/solved-how-enable-kerberos-armoring-eap-fast-ad/.
        /// </summary>
        public static string S_KerberosArmoring_Documentation {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify Kerberos Armoring is enabled on clients and the domain functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoring_Rationale {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If activated, the detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string S_KerberosArmoring_ReportLocation {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To enable Kerberos armoring for client, edit the GPO and go to Computer Configuration &gt; Administrative Templates &gt; System &gt; Kerberos
        ///    then enable the policy &quot;Kerberos client support for claims, compound authentication and Kerberos armoring&quot;..
        /// </summary>
        public static string S_KerberosArmoring_Solution {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos Armoring is an optimization of the Kerberos protocol. It avoids the pre-authentication steps thus prohibiting pre-authentication attacks;
        ///    It is supported only starting Windows Server 2012 DC and Windows 8 workstations.
        ///    If Kerberos armoring is requested for other operating systems (such as Windows 7 or Linux), the Kerberos authentication protocol may refuse to work.
        ///    .
        /// </summary>
        public static string S_KerberosArmoring_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that clients support Kerberos armoring when the domain functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoring_Title {
            get {
                return ResourceManager.GetString("S_KerberosArmoring_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that DC supports Kerberos armoring when functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoringDC_Description {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_KerberosArmoringDC_Detail {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/hh831747(v=ws.11)
        ///    https://pupuweb.com/solved-how-enable-kerberos-armoring-eap-fast-ad/.
        /// </summary>
        public static string S_KerberosArmoringDC_Documentation {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify Kerberos Armoring is enabled on DCs and the domain functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoringDC_Rationale {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If activated, the detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string S_KerberosArmoringDC_ReportLocation {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To enable Kerberos armoring for domain controllers, edit the GPO and go to Computer Configuration &gt; Administrative Templates &gt; System &gt; KDC
        ///    then enable the policy &quot;KDC support for claims, compound authentication and Kerberos armoring&quot;.
        ///  The policy should be set to at least &quot;Supported&quot;.
        ///  
        ///The safest settings is &quot;Fail authentication requests when Kerberos armoring is not available&quot; but it should be enabled only if the clients support Kerberos armoring..
        /// </summary>
        public static string S_KerberosArmoringDC_Solution {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Kerberos Armoring is an optimization of the Kerberos protocol. It avoids the pre-authentication steps and thereby prevents pre-authentication attacks.
        ///    It is supported only starting Windows Server 2012 DC and Windows 8 workstations.
        ///    If Kerberos Armoring is requested for other operating systems (such as Windows 7 or Linux), the Kerberos authentication protocol may refuse to work.
        ///    .
        /// </summary>
        public static string S_KerberosArmoringDC_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that DC supports Kerberos armoring when functional level is at least Windows Server 2012.
        /// </summary>
        public static string S_KerberosArmoringDC_Title {
            get {
                return ResourceManager.GetString("S_KerberosArmoringDC_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all accounts require Kerberos pre-authentication.
        /// </summary>
        public static string S_NoPreAuth_Description {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account: {0} Created: {1} LastLogon: {2}.
        /// </summary>
        public static string S_NoPreAuth_Detail {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to http://www.harmj0y.net/blog/activedirectory/roasting-as-reps/.
        /// </summary>
        public static string S_NoPreAuth_Documentation {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of accounts which do not require Kerberos pre-authentication: {count}.
        /// </summary>
        public static string S_NoPreAuth_Rationale {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_NoPreAuth_ReportLocation {
            get {
                return ResourceManager.GetString("S_NoPreAuth_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the property of the involved accounts and select the Account tab. Uncheck &quot;Do not require Kerberos preauthentication&quot;. For computers, which don&apos;t have the Account tab, you have to manually edit the attribute useraccountcontrol. Subtract 4194304 the value of the attribute..
        /// </summary>
        public static string S_NoPreAuth_Solution {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Without Kerberos pre-authentication, an attacker can request Kerberos data from the domain controller and use this data to crack the account password. You can find which accounts don&apos;t require Kerberos pre-authentication with the PowerShell command: &lt;i&gt;Get-ADObject -LDAPFilter &quot;(userAccountControl:1.2.840.113556.1.4.803:=4194304)&quot;&lt;/i&gt;.
        /// </summary>
        public static string S_NoPreAuth_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_NoPreAuth_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all accounts require Kerberos pre-authentication.
        /// </summary>
        public static string S_NoPreAuth_Title {
            get {
                return ResourceManager.GetString("S_NoPreAuth_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all admin accounts require Kerberos pre-authentication.
        /// </summary>
        public static string S_NoPreAuthAdmin_Description {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account: {0} Created: {1} LastLogon: {2}.
        /// </summary>
        public static string S_NoPreAuthAdmin_Detail {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to http://www.harmj0y.net/blog/activedirectory/roasting-as-reps/.
        /// </summary>
        public static string S_NoPreAuthAdmin_Documentation {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of admin accounts which do not require Kerberos pre-authentication: {count}.
        /// </summary>
        public static string S_NoPreAuthAdmin_Rationale {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_NoPreAuthAdmin_ReportLocation {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit the property of the involved accounts and select the Account tab. Uncheck &quot;Do not require Kerberos preauthentication&quot;. For computers, which don&apos;t have the Account tab, you have to manually edit the attribute useraccountcontrol. Subtract 4194304 from the value of the attribute..
        /// </summary>
        public static string S_NoPreAuthAdmin_Solution {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Without Kerberos pre-authentication, an attacker can request Kerberos data from the domain controller and use this data to brute-force the account password. You can search accounts using the LDAP query &lt;i&gt;(userAccountControl:1.2.840.113556.1.4.803:=4194304)&lt;/i&gt;.
        /// </summary>
        public static string S_NoPreAuthAdmin_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all admin accounts require Kerberos pre-authentication.
        /// </summary>
        public static string S_NoPreAuthAdmin_Title {
            get {
                return ResourceManager.GetString("S_NoPreAuthAdmin_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if NTLMv1 or LM can be used by DC.
        /// </summary>
        public static string S_OldNtlm_Description {
            get {
                return ResourceManager.GetString("S_OldNtlm_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Value: {1}.
        /// </summary>
        public static string S_OldNtlm_Detail {
            get {
                return ResourceManager.GetString("S_OldNtlm_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/audit-domain-controller-ntlmv1
        ///https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-restrict-ntlm-ntlm-authentication-in-this-domain
        ///https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-lan-manager-authentication-level
        ///https://learn.microsoft.com/en-us/troubleshoot/windows-client/windows-security/enable-ntlm-2-au [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OldNtlm_Documentation {
            get {
                return ResourceManager.GetString("S_OldNtlm_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The LAN Manager Authentication Level allows the use of NTLMv1 or LM..
        /// </summary>
        public static string S_OldNtlm_Rationale {
            get {
                return ResourceManager.GetString("S_OldNtlm_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#lsasettings&quot;&gt;Security settings&lt;/a&gt;.
        /// </summary>
        public static string S_OldNtlm_ReportLocation {
            get {
                return ResourceManager.GetString("S_OldNtlm_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to After an audit of NTLMv1 usage (see the links below), you need to raise the LAN Manager Authentication Level to &quot;Send NTLMv2 response only. Refuse LM &amp; NTLM&quot;.
        ///    This can be done by editing the policy &quot;Network security: LAN Manager authentication level&quot; which can be accessed in Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options
        ///    The policy will be applied after a computer reboot.
        ///    
        ///    Beware that you may break software which is not compatible with Ntlmv2 su [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OldNtlm_Solution {
            get {
                return ResourceManager.GetString("S_OldNtlm_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NTLMv1 is an old protocol which is known to be vulnerable to cryptographic attacks.
        ///    It is typically used when a hacker sniffs the network and tries to retrieve NTLM hashes which can then be used to impersonate users.
        ///    
        ///    This attack can be combined with coerced authentication attacks - a hacker forces the DC to connect to a controlled host.
        ///    In this case, NTLMv1 can be specified so the hacker can retrieve the NTLM hash of the DC, impersonates it and then take control of the domain.
        ///    This [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OldNtlm_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OldNtlm_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the NTLMv1 and old LM protocols are banned.
        /// </summary>
        public static string S_OldNtlm_Title {
            get {
                return ResourceManager.GetString("S_OldNtlm_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows 2000 for the workstations within the domain.
        /// </summary>
        public static string S_OS_2000_Description {
            get {
                return ResourceManager.GetString("S_OS_2000_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_2000_Documentation {
            get {
                return ResourceManager.GetString("S_OS_2000_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows 2000 = {count}.
        /// </summary>
        public static string S_OS_2000_Rationale {
            get {
                return ResourceManager.GetString("S_OS_2000_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_2000_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_2000_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_2000_Solution {
            get {
                return ResourceManager.GetString("S_OS_2000_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows 2000 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_2000_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_2000_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows 2000).
        /// </summary>
        public static string S_OS_2000_Title {
            get {
                return ResourceManager.GetString("S_OS_2000_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2003 for the workstations within the domain.
        /// </summary>
        public static string S_OS_2003_Description {
            get {
                return ResourceManager.GetString("S_OS_2003_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_2003_Documentation {
            get {
                return ResourceManager.GetString("S_OS_2003_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2003 = {count}.
        /// </summary>
        public static string S_OS_2003_Rationale {
            get {
                return ResourceManager.GetString("S_OS_2003_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_2003_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_2003_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10.   
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComput [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_2003_Solution {
            get {
                return ResourceManager.GetString("S_OS_2003_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows Server 2003 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_2003_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_2003_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows Server 2003).
        /// </summary>
        public static string S_OS_2003_Title {
            get {
                return ResourceManager.GetString("S_OS_2003_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2008 for the workstations within the domain.
        /// </summary>
        public static string S_OS_2008_Description {
            get {
                return ResourceManager.GetString("S_OS_2008_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-server-eos-faq/end-of-support-windows-server-2008-2008r2.
        /// </summary>
        public static string S_OS_2008_Documentation {
            get {
                return ResourceManager.GetString("S_OS_2008_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2008 = {count}.
        /// </summary>
        public static string S_OS_2008_Rationale {
            get {
                return ResourceManager.GetString("S_OS_2008_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_2008_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_2008_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the servers to a more recent version of Windows, starting from Windows Server 2012. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComp [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_2008_Solution {
            get {
                return ResourceManager.GetString("S_OS_2008_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows Server 2008 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_2008_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_2008_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows Server 2008).
        /// </summary>
        public static string S_OS_2008_Title {
            get {
                return ResourceManager.GetString("S_OS_2008_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Server 2012 for the workstations within the domain.
        /// </summary>
        public static string S_OS_2012_Description {
            get {
                return ResourceManager.GetString("S_OS_2012_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-US/lifecycle/products/windows-server-2012-r2.
        /// </summary>
        public static string S_OS_2012_Documentation {
            get {
                return ResourceManager.GetString("S_OS_2012_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Server 2012 = {count}.
        /// </summary>
        public static string S_OS_2012_Rationale {
            get {
                return ResourceManager.GetString("S_OS_2012_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_2012_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_2012_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the servers to a more recent version of Windows, starting from Windows Server 2012. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComp [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_2012_Solution {
            get {
                return ResourceManager.GetString("S_OS_2012_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows Server 2012 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_2012_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_2012_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows Server 2012).
        /// </summary>
        public static string S_OS_2012_Title {
            get {
                return ResourceManager.GetString("S_OS_2012_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows NT for the workstations within the domain.
        /// </summary>
        public static string S_OS_NT_Description {
            get {
                return ResourceManager.GetString("S_OS_NT_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_NT_Documentation {
            get {
                return ResourceManager.GetString("S_OS_NT_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows NT = {count}.
        /// </summary>
        public static string S_OS_NT_Rationale {
            get {
                return ResourceManager.GetString("S_OS_NT_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_NT_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_NT_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_NT_Solution {
            get {
                return ResourceManager.GetString("S_OS_NT_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows NT OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc.
        ///.
        /// </summary>
        public static string S_OS_NT_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_NT_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows NT).
        /// </summary>
        public static string S_OS_NT_Title {
            get {
                return ResourceManager.GetString("S_OS_NT_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows Vista for the workstations within the domain.
        /// </summary>
        public static string S_OS_Vista_Description {
            get {
                return ResourceManager.GetString("S_OS_Vista_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_Vista_Documentation {
            get {
                return ResourceManager.GetString("S_OS_Vista_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows Vista = {count}.
        /// </summary>
        public static string S_OS_Vista_Rationale {
            get {
                return ResourceManager.GetString("S_OS_Vista_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_Vista_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_Vista_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_Vista_Solution {
            get {
                return ResourceManager.GetString("S_OS_Vista_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows Vista OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_Vista_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_Vista_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows Vista).
        /// </summary>
        public static string S_OS_Vista_Title {
            get {
                return ResourceManager.GetString("S_OS_Vista_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of non-supported version of Windows 10 or Windows 11 within the domain.
        /// </summary>
        public static string S_OS_W10_Description {
            get {
                return ResourceManager.GetString("S_OS_W10_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Version: {0}  Number: {1} Active: {2}.
        /// </summary>
        public static string S_OS_W10_Detail {
            get {
                return ResourceManager.GetString("S_OS_W10_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/release-health/release-information.
        /// </summary>
        public static string S_OS_W10_Documentation {
            get {
                return ResourceManager.GetString("S_OS_W10_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of non-supported versions of Windows 10 or Windows 11 = {count} editions ( {activeComputers} active computers).
        /// </summary>
        public static string S_OS_W10_Rationale {
            get {
                return ResourceManager.GetString("S_OS_W10_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_W10_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_W10_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the Windows 10 or Windows 11 to a more recent version.    
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;    
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer -Filter {(Enabled [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_W10_Solution {
            get {
                return ResourceManager.GetString("S_OS_W10_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some versions of Windows 10 and Windows 11 OS are no longer supported, and may be vulnerable to exploits that are not patched anymore..
        /// </summary>
        public static string S_OS_W10_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_W10_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows 10 or Windows 11).
        /// </summary>
        public static string S_OS_W10_Title {
            get {
                return ResourceManager.GetString("S_OS_W10_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows 7 for the workstations within the domain.
        /// </summary>
        public static string S_OS_Win7_Description {
            get {
                return ResourceManager.GetString("S_OS_Win7_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/t5/windows-it-pro-blog/activate-windows-7-esus-on-multiple-devices-with-a-mak/ba-p/1167196.
        /// </summary>
        public static string S_OS_Win7_Documentation {
            get {
                return ResourceManager.GetString("S_OS_Win7_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows 7 = {count}.
        /// </summary>
        public static string S_OS_Win7_Rationale {
            get {
                return ResourceManager.GetString("S_OS_Win7_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_Win7_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_Win7_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_Win7_Solution {
            get {
                return ResourceManager.GetString("S_OS_Win7_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows 7 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc.
        ///PingCastle is trying to guess if Extended Security Support (ESU) has been purchased from Microsoft. Based on the documentation referenced below, the program checks if the script Activate-ProductOnline.ps1 is present.
        ///If the script is detected, Windows 7 is considered as supported and this rule is not triggered..
        /// </summary>
        public static string S_OS_Win7_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_Win7_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows 7).
        /// </summary>
        public static string S_OS_Win7_Title {
            get {
                return ResourceManager.GetString("S_OS_Win7_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows 8 for the workstations within the domain.
        /// </summary>
        public static string S_OS_Win8_Description {
            get {
                return ResourceManager.GetString("S_OS_Win8_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_Win8_Documentation {
            get {
                return ResourceManager.GetString("S_OS_Win8_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows 8 = {count}.
        /// </summary>
        public static string S_OS_Win8_Rationale {
            get {
                return ResourceManager.GetString("S_OS_Win8_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_Win8_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_Win8_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10.     
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;        
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Ge [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_Win8_Solution {
            get {
                return ResourceManager.GetString("S_OS_Win8_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows 8 OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_Win8_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_Win8_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows 8).
        /// </summary>
        public static string S_OS_Win8_Title {
            get {
                return ResourceManager.GetString("S_OS_Win8_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no use of the obsolete and vulnerable OS Windows XP for the workstations within the domain.
        /// </summary>
        public static string S_OS_XP_Description {
            get {
                return ResourceManager.GetString("S_OS_XP_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_OS_XP_Documentation {
            get {
                return ResourceManager.GetString("S_OS_XP_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of Windows XP = {count}.
        /// </summary>
        public static string S_OS_XP_Rationale {
            get {
                return ResourceManager.GetString("S_OS_XP_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#operatingsystems&quot;&gt;Operating Systems&lt;/a&gt;.
        /// </summary>
        public static string S_OS_XP_ReportLocation {
            get {
                return ResourceManager.GetString("S_OS_XP_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to solve this security issue, you should upgrade all the workstations to a more recent version of Windows, starting from Windows 10. 
        ///    &lt;i&gt;&lt;strong&gt;Use PingCastle.exe and select export on the main menu. Then choose to export computers. PingCastle will produce a list of all your computers with the OS version in a csv file. You can then use Excel to filter them.&lt;/strong&gt;&lt;/i&gt;
        ///    Do note that you can get the full details regarding the OS used with the following PowerShell command: &lt;i&gt;Get-ADComputer [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_OS_XP_Solution {
            get {
                return ResourceManager.GetString("S_OS_XP_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Windows XP OS is no longer supported, as it is vulnerable to many publicly known exploits: Administrator&apos;s credentials can be captured, security protocols are weak, etc..
        /// </summary>
        public static string S_OS_XP_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_OS_XP_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete OS (Windows XP).
        /// </summary>
        public static string S_OS_XP_Title {
            get {
                return ResourceManager.GetString("S_OS_XP_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check for unusual values in the primarygroupid attribute used to store group memberships.
        /// </summary>
        public static string S_PrimaryGroup_Description {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string S_PrimaryGroup_Detail {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_PrimaryGroup_Documentation {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Presence of wrong primary group for users: {count}.
        /// </summary>
        public static string S_PrimaryGroup_Rationale {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Auditor| monitors and alerts on changes to group memberships in Active Directory, with a complete audit trail for accountability.\r\nNetwrix Threat Manager| monitors and alerts on unauthorized changes to group memberships, with the option to block them, preventing privilege escalation.\r\nNetwrix Access Analyzer| detects hidden group memberships for user accounts and can remediate security risks by removing users from groups in bulk..
        /// </summary>
        public static string S_PrimaryGroup_RelevantProducts {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_PrimaryGroup_ReportLocation {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unless strongly justified, change the primary group id to its default: 513 or 514 for users, 516 or 521 for domain controllers, 514 or 515 for computers. The primary group can be edited in a friendly manner by editing the account with the &quot;Active Directory Users and Computers&quot; and after selecting the &quot;Member Of&quot; tab, &quot;set primary group&quot;.
        ///    You can use the following script to list Users with a primary group id different from domain users:
        ///    &lt;i&gt;$DomainUsersSid = New-Object System.Security.Principal.Secu [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_PrimaryGroup_Solution {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In Active Directory, group membership is stored on the &quot;members&quot; attribute and on the &quot;primarygroupid&quot; attribute. The default primary group value is &quot;Domain Users&quot; for the users, &quot;Domain Computers&quot; for the computers and &quot;Domain Controllers&quot; for the domain controllers. The primarygroupid contains the RID (last digits of a SID) of the group targeted. It can be used to store hidden membership as this attribute is not often analyzed..
        /// </summary>
        public static string S_PrimaryGroup_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for hidden group membership for user accounts.
        /// </summary>
        public static string S_PrimaryGroup_Title {
            get {
                return ResourceManager.GetString("S_PrimaryGroup_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the regular change of computer account passwords is active.
        /// </summary>
        public static string S_PwdLastSet_45_Description {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Computer: {0} Creation: {1} LastUsed: {2} LastChange: {3}.
        /// </summary>
        public static string S_PwdLastSet_45_Detail {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/disable-machine-account-password
        ///https://access.redhat.com/discussions/1283873.
        /// </summary>
        public static string S_PwdLastSet_45_Documentation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of computers without password change: {count}.
        /// </summary>
        public static string S_PwdLastSet_45_Rationale {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Privilege Secure| helps ensure endpoint passwords are automatically updated and privileges are eliminated when not in use, reducing the attack surface for lateral movement..
        /// </summary>
        public static string S_PwdLastSet_45_RelevantProducts {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_PwdLastSet_45_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      Some security agencies report the absence of password change as an indicator of compromise.
        ///      
        ///      If it is not the case, check the following registry keys:
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\DisablePasswordChange: must be set to 0 or inexistent;
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\MaximumPasswordAge: must be set to 30.
        ///
        ///For Linux systems, the password change may not be enabled by default - solutions exist, see the link in documentation, [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_PwdLastSet_45_Solution {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, all computers automatically change their AD password every 30 days.
        ///    Changing regularly secrets like passwords ensures that they are not used in side channel attacks.
        ///    Also with the default possibility to create up to 10 computers accounts, these accounts may be seen as a backdoor.
        ///    
        ///    This audit program considers this as an anomaly between 45 days and 90 days.
        ///    Also this rule is the companion for the rule S-PwdLastSet-90
        ///    .
        /// </summary>
        public static string S_PwdLastSet_45_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all computers are using regular password change practices..
        /// </summary>
        public static string S_PwdLastSet_45_Title {
            get {
                return ResourceManager.GetString("S_PwdLastSet_45_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that all computer accounts have their password changed in the last 3 months.
        /// </summary>
        public static string S_PwdLastSet_90_Description {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Computer: {0} Creation: {1} LastUsed: {2} LastChange: {3}.
        /// </summary>
        public static string S_PwdLastSet_90_Detail {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/disable-machine-account-password
        ///https://access.redhat.com/discussions/1283873.
        /// </summary>
        public static string S_PwdLastSet_90_Documentation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of computers without password change for at least 3 months: {count}.
        /// </summary>
        public static string S_PwdLastSet_90_Rationale {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| automates password expiry notifications and group management based on users&apos; password expiration dates..
        /// </summary>
        public static string S_PwdLastSet_90_RelevantProducts {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_PwdLastSet_90_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      Some security agencies report the absence of password change as an indicator of compromise.
        ///      
        ///      If it is not the case, check the following registry keys:
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\DisablePasswordChange: must be set to 0 or inexistent;
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\MaximumPasswordAge: must be set to 30.
        ///
        ///For Linux systems, the password change may not be enabled by default - solutions exist, see the link in documentation, [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_PwdLastSet_90_Solution {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, all computers automatically change their AD password every 30 days.
        ///    Changing regularly secrets like passwords ensures that they are not used in side channel attacks.
        ///    Also with the default possibility to create up to 10 computers accounts, these accounts may be seen as a backdoor.
        ///    
        ///    This audit program considers this as an anomaly starting with 90 days.
        ///    Also this rule is the companion for the rule S-PwdLastSet-45 which does the same between 45 and 90 days
        ///    .
        /// </summary>
        public static string S_PwdLastSet_90_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all computers have changed their passwords in the last 3 months..
        /// </summary>
        public static string S_PwdLastSet_90_Title {
            get {
                return ResourceManager.GetString("S_PwdLastSet_90_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the regular change of cluster account is active..
        /// </summary>
        public static string S_PwdLastSet_Cluster_Description {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cluster: {0} LastChange: {1}.
        /// </summary>
        public static string S_PwdLastSet_Cluster_Detail {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/failover-clustering/configure-ad-accounts.
        /// </summary>
        public static string S_PwdLastSet_Cluster_Documentation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of Cluster without password change: {count}.
        /// </summary>
        public static string S_PwdLastSet_Cluster_Rationale {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_PwdLastSet_Cluster_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      Certain accounts on Windows server clusters have maintained static passwords for over three years, suggesting a lack of secret refreshes.
        ///      
        ///      To determine why the password hasn’t been updated, you must examine the cluster configuration and event logs.
        ///	  Please consult the cited reference document to carry out this process.
        ///    .
        /// </summary>
        public static string S_PwdLastSet_Cluster_Solution {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The algorithm identifies clusters by checking three conditions:
        ///1. The account is active, as indicated by the UserAccountControl flag not being set to 2.
        ///2. The account was created at least three years ago but has been used within the last 45 days according to the attribute lastlogontimestamp.
        ///3. The password was last set at least three years prior to the most recent login.
        ///    .
        /// </summary>
        public static string S_PwdLastSet_Cluster_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all cluster are using regular password change practices..
        /// </summary>
        public static string S_PwdLastSet_Cluster_Title {
            get {
                return ResourceManager.GetString("S_PwdLastSet_Cluster_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the regular change of computer account is active on Domain Controllers..
        /// </summary>
        public static string S_PwdLastSet_DC_Description {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} LastChange: {1}.
        /// </summary>
        public static string S_PwdLastSet_DC_Detail {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/disable-machine-account-password.
        /// </summary>
        public static string S_PwdLastSet_DC_Documentation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC without password change: {count}.
        /// </summary>
        public static string S_PwdLastSet_DC_Rationale {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_PwdLastSet_DC_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      Some security agencies report the absence of password change as an indicator of compromise.
        ///      
        ///      If it is not the case, check the following registry keys:
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\DisablePasswordChange: must be set to 0 or inexistent;
        ///* HKLM\System\CurrentControlSet\Services\Netlogon\Parameters\MaximumPasswordAge: must be set to 30.
        ///    .
        /// </summary>
        public static string S_PwdLastSet_DC_Solution {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, each computers automatically change its password every 30 days. This is the same case for domain controllers.
        ///    Changing regularly secrets like passwords ensures that they are not used in side channel attacks.
        ///    For exemple, using DCSync to export the hash of a domain controller password, then reusing it in a silver attack to create Kerberos tickets.
        ///    
        ///    This audit program considers this as an anomaly after 45 days.
        ///    .
        /// </summary>
        public static string S_PwdLastSet_DC_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if all DC are using regular password change practices..
        /// </summary>
        public static string S_PwdLastSet_DC_Title {
            get {
                return ResourceManager.GetString("S_PwdLastSet_DC_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that every account has a password which is compliant with password expiration policies.
        /// </summary>
        public static string S_PwdNeverExpires_Description {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string S_PwdNeverExpires_Detail {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://adsecurity.org/?p=4115
        ///https://access.redhat.com/discussions/1283873.
        /// </summary>
        public static string S_PwdNeverExpires_Documentation {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of accounts which have never expiring passwords: {count}.
        /// </summary>
        public static string S_PwdNeverExpires_Rationale {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| automatically enforces secure configurations during account creation or management to ensure the &quot;Password Never Expires&quot; setting is not misused. \r\nNetwrix Privilege Secure| helps mandate regular password updates for privileged accounts, regardless of expiration settings, with strong, complex passwords to mitigate long-term compromise risks..
        /// </summary>
        public static string S_PwdNeverExpires_RelevantProducts {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt;.
        /// </summary>
        public static string S_PwdNeverExpires_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to make Active Directory enforce periodic password change, accounts must not have the &quot;Password never expires&quot; flag set in the &quot;Account&quot; tab of the user properties. Their passwords should then be rolled immediately.
        ///For service accounts, Windows provides the &quot;managed service accounts&quot; and &quot;group managed service accounts&quot; features to facilitate the automatic change of passwords.
        ///Please note that there is a document in the section below which references solutions for service accounts of well known  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_PwdNeverExpires_Solution {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some accounts have passwords which never expire. Should an attacker compromise one of these accounts, he would be able to maintain long-term access to the Active Directory domain.
        ///    
        ///We have noted that some Linux servers, domain joined, are configured with a password which never expires.
        ///This is a misconfiguration because a password change can be configured. It was however not the default on some plateform.
        ///See one of the link below for more information..
        /// </summary>
        public static string S_PwdNeverExpires_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check that there is no account with never-expiring passwords.
        /// </summary>
        public static string S_PwdNeverExpires_Title {
            get {
                return ResourceManager.GetString("S_PwdNeverExpires_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that every account requires a password.
        /// </summary>
        public static string S_PwdNotRequired_Description {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string S_PwdNotRequired_Detail {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties.
        /// </summary>
        public static string S_PwdNotRequired_Documentation {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of accounts which can have an empty password (can be overridden by GPO): {count}.
        /// </summary>
        public static string S_PwdNotRequired_Rationale {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Netwrix Directory Manager| simplifies account creation and management by automatically enforcing proper configurations, ensuring the &quot;Password Not Required&quot; setting is never enabled. \r\nNetwrix Privilege Secure| enforces strong, complex passwords and prevents unauthorized use of the &quot;PASSWD_NOTREQD&quot; flag, eliminating password-less account vulnerabilities..
        /// </summary>
        public static string S_PwdNotRequired_RelevantProducts {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_RelevantProducts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_PwdNotRequired_ReportLocation {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The best solution to solve the problem is to change the &quot;useraccountcontrol&quot; attribute of all the accounts that have it and that are not used in trusts. If the flag is removed while there is no password set, you will have an error. You can use this to detect accounts without any passwords. Do note that you can manually check all the accounts that need to be worked on using the following PowerShell command: &lt;i&gt;get-adobject -ldapfilter &quot;(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.11 [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_PwdNotRequired_Solution {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An account can be set without a password if it has the flag &quot;PASSWD_NOTREQD&quot; set as &quot;True&quot; in the &quot;useraccountcontrol&quot; attribute. This represents a high security risk as the account is not protected at all without a password.
        /// </summary>
        public static string S_PwdNotRequired_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check that every account requires a password.
        /// </summary>
        public static string S_PwdNotRequired_Title {
            get {
                return ResourceManager.GetString("S_PwdNotRequired_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if there are user accounts currently running with a reversible password.
        /// </summary>
        public static string S_Reversible_Description {
            get {
                return ResourceManager.GetString("S_Reversible_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_Reversible_Documentation {
            get {
                return ResourceManager.GetString("S_Reversible_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of account(s) which have a reversible password: {count}.
        /// </summary>
        public static string S_Reversible_Rationale {
            get {
                return ResourceManager.GetString("S_Reversible_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt;.
        /// </summary>
        public static string S_Reversible_ReportLocation {
            get {
                return ResourceManager.GetString("S_Reversible_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To remove this risk, there should be no account(s) with reversible encryption. You should remove them by removing the flag &quot;Store password using reversible encryption&quot; on all accounts, so that the cleartext password is removed at the next password change. You can get a list of all the possibly compromised accounts running the following PowerShell command: &lt;i&gt;get-adobject -ldapfilter &quot;(userAccountControl:1.2.840.113556.1.4.803:=128)&quot; -properties useraccountcontrol&lt;/i&gt;.
        /// </summary>
        public static string S_Reversible_Solution {
            get {
                return ResourceManager.GetString("S_Reversible_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is possible that domains have accounts with an encryption that can be reversed. In this case, it means that the password is actually stored in clear text in the &lt;i&gt;supplementalCredential&lt;/i&gt; attribute of the account and that it can be retrieved using a DCSync attack.
        /// </summary>
        public static string S_Reversible_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Reversible_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for reversible password used for user accounts.
        /// </summary>
        public static string S_Reversible_Title {
            get {
                return ResourceManager.GetString("S_Reversible_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DN: {0}.
        /// </summary>
        public static string S_ServiceDomainAdmin_Detail {
            get {
                return ResourceManager.GetString("S_ServiceDomainAdmin_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that a migration has been completed correctly and that the SIDHistory attribute has been cleared out from user and computer accounts. This attribute is indeed set when migrating a user or a computer from one domain to another.
        /// </summary>
        public static string S_SIDHistory_Description {
            get {
                return ResourceManager.GetString("S_SIDHistory_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SID: {0} Object(s): {1}.
        /// </summary>
        public static string S_SIDHistory_Detail {
            get {
                return ResourceManager.GetString("S_SIDHistory_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_SIDHistory_Documentation {
            get {
                return ResourceManager.GetString("S_SIDHistory_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} domain(s) used in SIDHistory.
        /// </summary>
        public static string S_SIDHistory_Rationale {
            get {
                return ResourceManager.GetString("S_SIDHistory_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt; and a quick summary in &lt;a href=&quot;#sidhistory&quot;&gt;SID History&lt;/a&gt;.
        /// </summary>
        public static string S_SIDHistory_ReportLocation {
            get {
                return ResourceManager.GetString("S_SIDHistory_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To solve the security issue, you should remove all the SIDHistory attributes. To do so, you can list the objects having a SIDHistory attribute using the command: &lt;i&gt;get-ADObject -ldapfilter &quot;(sidhistory=*)&quot; -properties sidhistory&lt;/i&gt;. 
        ///Each security descriptor of the domain, including file shares for example, should be reviewed to be rewritten with the new SID of the account. Then, the attribute can be removed of these accounts using the migration tool or a PowerShell snippet &lt;i&gt;Remove-SIDHistory&lt;/i&gt; once  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_SIDHistory_Solution {
            get {
                return ResourceManager.GetString("S_SIDHistory_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory attribute is useful when doing a migration because it allows to keep the reference to the former account. On the other hand, once the migration is over, it is mandatory that this attribute is removed to evaluate the permissions in regards with the new account and not the former one..
        /// </summary>
        public static string S_SIDHistory_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_SIDHistory_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SIDHistory check.
        /// </summary>
        public static string S_SIDHistory_Title {
            get {
                return ResourceManager.GetString("S_SIDHistory_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if Domain Controller(s) are vulnerable to the SMB v1 vulnerability.
        /// </summary>
        public static string S_SMB_v1_Description {
            get {
                return ResourceManager.GetString("S_SMB_v1_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0}.
        /// </summary>
        public static string S_SMB_v1_Detail {
            get {
                return ResourceManager.GetString("S_SMB_v1_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://github.com/lgandx/Responder-Windows
        ///https://learn.microsoft.com/en-us/archive/blogs/josebda/the-deprecation-of-smb1-you-should-be-planning-to-get-rid-of-this-old-smb-dialect
        ///https://learn.microsoft.com/windows-server/storage/file-server/troubleshoot/detect-enable-and-disable-smbv1-v2-v3.
        /// </summary>
        public static string S_SMB_v1_Documentation {
            get {
                return ResourceManager.GetString("S_SMB_v1_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMB v1 activated on {count} DC.
        /// </summary>
        public static string S_SMB_v1_Rationale {
            get {
                return ResourceManager.GetString("S_SMB_v1_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_SMB_v1_ReportLocation {
            get {
                return ResourceManager.GetString("S_SMB_v1_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is highly recommended by Microsoft to disable SMB v1 whenever it is possible on both client and server-side. &lt;b&gt;Do note that if you are still not following best practices regarding the usage of deprecated OS (Windows 2000, 2003, XP, CE), regarding Network printer using SMBv1 scan2shares functionalities, or regarding software accessing Windows share with a custom implementation relying on SMB v1, you should consider fixing these issues before disabling SMB v1, as it will generate additional errors&lt;/b&gt;..
        /// </summary>
        public static string S_SMB_v1_Solution {
            get {
                return ResourceManager.GetString("S_SMB_v1_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SMB downgrade attack is used to obtain credentials or executing commands on behalf of a user by using SMB v1 as protocol. Indeed, because SMB v1 supports old authentication protocol, the integrity can be bypassed.
        /// </summary>
        public static string S_SMB_v1_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_SMB_v1_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC vulnerability (SMB v1).
        /// </summary>
        public static string S_SMB_v1_Title {
            get {
                return ResourceManager.GetString("S_SMB_v1_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies the recommended configuration for Terminal Services..
        /// </summary>
        public static string S_TerminalServicesGPO_Description {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Reason: {1}.
        /// </summary>
        public static string S_TerminalServicesGPO_Detail {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://woshub.com/remote-desktop-session-time-limit/
        ///    https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/ce70794f-2138-43e8-bf6c-2c147887d6a2
        ///  https://community.spiceworks.com/t/are-redirected-printers-a-security-risk/826344/27.
        /// </summary>
        public static string S_TerminalServicesGPO_Documentation {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The GPO are not pushing recommended configuration for Terminal Services.
        /// </summary>
        public static string S_TerminalServicesGPO_Rationale {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string S_TerminalServicesGPO_ReportLocation {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Terminal Services configuration can be found in Policies / Administrative Templates / Windows Components / Remote Desktop Services / Remote Desktop Session Host
        ///    The details of this rule is located in Printer Redirection and Session Time Limits.
        ///    
        ///      PingCastle recommends to set the following Policy:
        ///Set time limit for disconnected sessions: 2h (aka MaxDisconnectionTime)
        ///Set time limit for active but idle Remote Desktop Services sessions: 8h (aka MaxIdleTime)
        ///Do not allow client printer r [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_TerminalServicesGPO_Solution {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is a common practice for hackers to look for open sessions on remote servers.
        ///    This can be done by attempting to open the user registry and checking if there is an access denied error or if the registry hive is not available at all. 
        ///    If found, the hacker can exploit this information by targeting this computer, or if the session is still active, hijack it and impact the client computer.
        ///    Indeed, you can access the local drive by default and push a malicious file such as a login script in the  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_TerminalServicesGPO_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify Terminal Services configuration best practices in GPO.
        /// </summary>
        public static string S_TerminalServicesGPO_Title {
            get {
                return ResourceManager.GetString("S_TerminalServicesGPO_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if Domain Controller(s) are vulnerable to the MS14-068 vulnerability.
        /// </summary>
        public static string S_Vuln_MS14_068_Description {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Reason: {1}.
        /// </summary>
        public static string S_Vuln_MS14_068_Detail {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.microsoft.com/en-us/msrc?rtc=1.
        /// </summary>
        public static string S_Vuln_MS14_068_Documentation {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC(s) vulnerable to MS14-068 = {count} (&gt;0).
        /// </summary>
        public static string S_Vuln_MS14_068_Rationale {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The startup time of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_Vuln_MS14_068_ReportLocation {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To fix the security breach, you should patch the DC as soon as it has been established it was vulnerable. You can verify that using a program in the links: this program will check remotely the last startup time of the DC and evaluate the risk.
        /// </summary>
        public static string S_Vuln_MS14_068_Solution {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to MS14-068 is a critical vulnerability that was published on November, 18th 2014. It can be used to very quickly compromise an entire domain, which is why having DC still vulnerable to this publicly known vulnerability represents a high security risk..
        /// </summary>
        public static string S_Vuln_MS14_068_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC vulnerability (MS14-068) .
        /// </summary>
        public static string S_Vuln_MS14_068_Title {
            get {
                return ResourceManager.GetString("S_Vuln_MS14_068_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify if Domain Controller(s) are vulnerable to the MS17-010 vulnerability.
        /// </summary>
        public static string S_Vuln_MS17_010_Description {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain controller: {0} Reason: {1}, Operating System {2}.
        /// </summary>
        public static string S_Vuln_MS17_010_Detail {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.microsoft.com/en-us/msrc/blog/2017/04/protecting-customers-and-evaluating-risk
        ///https://github.com/misterch0c/shadowbroker/tree/master/windows/exploits .
        /// </summary>
        public static string S_Vuln_MS17_010_Documentation {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of DC(s) vulnerable to MS17-010 = {count} (&gt;0).
        /// </summary>
        public static string S_Vuln_MS17_010_Rationale {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The startup time of domain controllers can be found in &lt;a href=&quot;#domaincontrollersection&quot;&gt;Domain controllers&lt;/a&gt;.
        /// </summary>
        public static string S_Vuln_MS17_010_ReportLocation {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To fix the security breach, you should patch the DC as soon as it has been established it was vulnerable. Another good remediation is to disable SMB v1 (see &quot;DC Vulnerability (SMB v1)). You can verify that using the program from github in the links: this program will check remotely the last startup time of the DC and evaluate the risk.
        /// </summary>
        public static string S_Vuln_MS17_010_Solution {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to MS17-010 is a critical vulnerability that was published on March, 14th 2017. It can be used to compromise an entire domain via DC compromise. This exploit has been revealed by the Shadow brokers (EternalBlue, EternalRomance, EternalSinergy) and it uses the SMB v1 vulnerability.
        /// </summary>
        public static string S_Vuln_MS17_010_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DC vulnerability (MS17-010) .
        /// </summary>
        public static string S_Vuln_MS17_010_Title {
            get {
                return ResourceManager.GetString("S_Vuln_MS17_010_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no access of WSUS server via HTTP.
        /// </summary>
        public static string S_WSUS_HTTP_Description {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0} Server: {1}.
        /// </summary>
        public static string S_WSUS_HTTP_Detail {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://www.gosecure.net/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks/
        ///https://github.com/pimps/wsuxploit
        ///https://github.com/GoSecure/WSuspicious
        ///https://learn.microsoft.com/en-us/windows/deployment/update/waas-wu-settings.
        /// </summary>
        public static string S_WSUS_HTTP_Documentation {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to WSUS is configured with unencrypted HTTP instead of HTTPS.
        /// </summary>
        public static string S_WSUS_HTTP_Rationale {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#WSUSsettings&quot;&gt;WSUS settings&lt;/a&gt; section..
        /// </summary>
        public static string S_WSUS_HTTP_ReportLocation {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to WSUS needs to be configured with HTTPS.
        ///See this guide for more information:
        ///https://learn.microsoft.com/en-us/windows-server/administration/windows-server-update-services/deploy/2-configure-wsus#23-secure-wsus-with-the-secure-sockets-layer-protocol
        ///    
        ///Then all GPO which reference the HTTP path should be changed to the HTTPS path.
        ///This program is looking at the settings defined in &quot;Set the intranet update service for detecting updates&quot; and &quot;Set the alternate download server&quot; in GPO Computer Configura [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_WSUS_HTTP_Solution {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to WSUS is the component used on the intranet to deliver Windows updates. The recommendation of Microsoft is to use HTTPS for transport but for convenience or tests, HTTP can be configured.
        ///The HTTP protocol can be intercepted on the network with tools such as wsuxploit or WSuspicious (see below for links) and malicious updates can be delivered.
        ///The attacker can then take control of many assets..
        /// </summary>
        public static string S_WSUS_HTTP_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search for WSUS configuration using HTTP instead of HTTPS.
        /// </summary>
        public static string S_WSUS_HTTP_Title {
            get {
                return ResourceManager.GetString("S_WSUS_HTTP_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that WSUS Certificate Pinning has not been disabled.
        /// </summary>
        public static string S_WSUS_NoPinning_Description {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string S_WSUS_NoPinning_Detail {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://www.gosecure.net/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks/
        ///https://github.com/pimps/wsuxploit
        ///https://github.com/GoSecure/WSuspicious
        ///https://learn.microsoft.com/en-us/windows/client-management/mdm/policy-csp-update#update-donotenforceenterprisetlscertpinningforupdatedetection
        ///  .
        /// </summary>
        public static string S_WSUS_NoPinning_Documentation {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Certificate Pinning security of WSUS has been disabled.
        /// </summary>
        public static string S_WSUS_NoPinning_Rationale {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#WSUSsettings&quot;&gt;WSUS settings&lt;/a&gt; section..
        /// </summary>
        public static string S_WSUS_NoPinning_ReportLocation {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the setting which disables the certificate pinning for WSUS.
        ///    
        ///    It is located in: Computer Configuration\Policies\Administrative Templates\Windows Components\Windows Update\Specify intranet Microsoft update service location
        ///  This is the setting &quot;Allow user proxy to be used as a fallback if detection using system proxy fails&quot;.
        ///  
        ///  It refers to the registry key: HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\DoNotEnforceEnterpriseTLSCertPinningForUpdateDetection
        ///.
        /// </summary>
        public static string S_WSUS_NoPinning_Solution {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Even though HTTPS makes it harder for attackers to intercept WSUS responses, it it still possible with a specific configuration.
        ///    HTTPS connections may be intercepted by a proxy that signs the response again with a self-signed certificate after receiving it from the WSUS server.
        ///    The certificate can be installed in a user cert store so responses from the HTTPS proxy can still be validated.
        ///In the cumulative update of January 2021, Microsoft implemented a certificate pinning mechanism where the cert [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_WSUS_NoPinning_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search for WSUS configuration where certificate pinning has been disabled.
        /// </summary>
        public static string S_WSUS_NoPinning_Title {
            get {
                return ResourceManager.GetString("S_WSUS_NoPinning_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no user proxy possibility for WSUS.
        /// </summary>
        public static string S_WSUS_UserProxy_Description {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GPO: {0}.
        /// </summary>
        public static string S_WSUS_UserProxy_Detail {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///https://www.gosecure.net/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks/
        ///https://github.com/pimps/wsuxploit
        ///https://github.com/GoSecure/WSuspicious
        ///https://learn.microsoft.com/en-us/windows/client-management/mdm/policy-csp-update#update-setproxybehaviorforupdatedetection
        ///  .
        /// </summary>
        public static string S_WSUS_UserProxy_Documentation {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to WSUS is configured to accept user proxy.
        /// </summary>
        public static string S_WSUS_UserProxy_Rationale {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in the &lt;a href=&quot;#WSUSsettings&quot;&gt;WSUS settings&lt;/a&gt; section..
        /// </summary>
        public static string S_WSUS_UserProxy_ReportLocation {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The use of a user proxy needs to be disabled.
        ///    This program is looking at element named &quot;Select the proxy behavior&quot; defined in GPO Computer Configuration\Policies\Administrative Templates\Windows Components\Windows Update\Specify intranet Microsoft update service location
        ///(refers to registry key HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\SetProxyBehaviorForUpdateDetection)
        ///
        ///Or WSUS needs to be configured with HTTPS.
        ///See this guide for more information:
        ///https://learn.microsoft.com/en-us/ [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_WSUS_UserProxy_Solution {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unprivileged domain users may set a user proxy that is used for Windows Update if it is being allowed by a GPO.
        ///    Since the cumulative updates from September 2020 and January 2021, WSUS clients do not use the user proxy to connect to the server by default.
        ///    However, it is possible to configure a GPO setting that allows the connection via user proxy as a fallback to the system proxy.
        ///  
        ///    This program consider as an anomaly if the setting SetProxyBehaviorForUpdateDetection is set, combined with a  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string S_WSUS_UserProxy_TechnicalExplanation {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search for WSUS configuration enabling the use of a user proxy.
        /// </summary>
        public static string S_WSUS_UserProxy_Title {
            get {
                return ResourceManager.GetString("S_WSUS_UserProxy_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Isolation of domains is critical to avoid a global compromise..
        /// </summary>
        public static string SIDFiltering_Detail {
            get {
                return ResourceManager.GetString("SIDFiltering_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When doing migrations, a double identity may be attributed. It can have side effects up to the compromise of the domain..
        /// </summary>
        public static string SIDHistory_Detail {
            get {
                return ResourceManager.GetString("SIDHistory_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if AES can be used with Kerberos on trusts.
        /// </summary>
        public static string T_AlgsAES_Description {
            get {
                return ResourceManager.GetString("T_AlgsAES_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trust: {0} Reason: {1}.
        /// </summary>
        public static string T_AlgsAES_Detail {
            get {
                return ResourceManager.GetString("T_AlgsAES_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://techcommunity.microsoft.com/t5/itops-talk-blog/tough-questions-answered-can-i-disable-rc4-etype-for-kerberos-on/ba-p/382718
        ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/6cfc7b50-11ed-4b4d-846d-6f08f0812919
        ///https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/decrypting-the-selection-of-supported-kerberos-encryption-types/ba-p/1628797.
        /// </summary>
        public static string T_AlgsAES_Documentation {
            get {
                return ResourceManager.GetString("T_AlgsAES_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to AES is not enabled on all trusts.
        /// </summary>
        public static string T_AlgsAES_Rationale {
            get {
                return ResourceManager.GetString("T_AlgsAES_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enable AES on the domain.
        ///    
        ///    Beware: there is a checkbox in the trust properties named &quot;The other domain supports Kerberos AES Encryption&quot;.
        ///    If you enable this setting, AES will be enabled but RC4 will also be disabled.
        ///    
        ///    The recommended way is to enable both RC4 and AES as a transition. It can be done by running the command:
        ///    &lt;i&gt;ksetup /setenctypeattr mytrust.com RC4-HMAC-MD5 AES128-CTS-HMAC-SHA1-96 AES256-CTS-HMAC-SHA1-96&lt;/i&gt;
        ///    
        ///      This way, the attribute msDS-SupportedEncr [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_AlgsAES_Solution {
            get {
                return ResourceManager.GetString("T_AlgsAES_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, RC4 is used as the signature algorithm on Kerberos tickets.
        ///    If AES is enabled on a domain and AES is not enabled on trust, AES tickets will not be usable on the trust. The Kerberos tickets sent to the trust will fail or the trusted domain will fallback to NTLM.
        ///    
        ///    The encryption algorithms allowed for a trust are stored in an attribute named msDS-SupportedEncryptionTypes.
        ///    If this attribute is not set (or has a value of zero), RC4 will be applied by default.
        ///    Else, it define [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_AlgsAES_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_AlgsAES_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if AES is enabled on trusts.
        /// </summary>
        public static string T_AlgsAES_Title {
            get {
                return ResourceManager.GetString("T_AlgsAES_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check that password rotation is in place with Entra ID SSO.
        /// </summary>
        public static string T_AzureADSSO_Description {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string T_AzureADSSO_Detail {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-sso-faq#how-can-i-roll-over-the-kerberos-decryption-key-of-the-azureadssoacc-computer-account
        ///https://itpro-tips.com/wp-content/uploads/files/TechnetGallery/Azure-AD-SSO-Key-Rollover-d2f1604a.zip
        ///https://www.dsinternals.com/en/impersonating-office-365-users-mimikatz/.
        /// </summary>
        public static string T_AzureADSSO_Documentation {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The password used in Entra ID SSO has not been changed for at least one year.
        /// </summary>
        public static string T_AzureADSSO_Rationale {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#azure&quot;&gt;Azure&lt;/a&gt;.
        /// </summary>
        public static string T_AzureADSSO_ReportLocation {
            get {
                return ResourceManager.GetString("T_AzureADSSO_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Run the script referenced in the documentation below to change the password of the account AZUREADSSOACC..
        /// </summary>
        public static string T_AzureADSSO_Solution {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Entra ID SSO is performed using a gateway. This gateway converts a Kerberos TGS ticket to a SAML ticket.
        ///    In short, a connection is made to the computer account AZUREADSSOACC and the secret of this user account is used as a shared secret with Entra ID.
        ///  Despite the fact that this computer account should have its password automatically changed every 30 days, it did not happen.
        ///That means that an extraction of its password (using DCSync for example) can lead to an Entra ID compromise..
        /// </summary>
        public static string T_AzureADSSO_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_AzureADSSO_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if password rotation is in place with Entra ID SSO.
        /// </summary>
        public static string T_AzureADSSO_Title {
            get {
                return ResourceManager.GetString("T_AzureADSSO_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that there is no NT4 compatible trust.
        /// </summary>
        public static string T_Downlevel_Description {
            get {
                return ResourceManager.GetString("T_Downlevel_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trust: {0}.
        /// </summary>
        public static string T_Downlevel_Detail {
            get {
                return ResourceManager.GetString("T_Downlevel_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/36565693-b5e4-4f37-b0a8-c1b12138e18e.
        /// </summary>
        public static string T_Downlevel_Documentation {
            get {
                return ResourceManager.GetString("T_Downlevel_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one trust DownLevel has been found. This is a NT4 compatible trust: {count}.
        /// </summary>
        public static string T_Downlevel_Rationale {
            get {
                return ResourceManager.GetString("T_Downlevel_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#discovereddomains&quot;&gt;Trusts section&lt;/a&gt;.
        /// </summary>
        public static string T_Downlevel_ReportLocation {
            get {
                return ResourceManager.GetString("T_Downlevel_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unless the remote party of the trust is a NT4 domain, this trust shouldn&apos;t exist. It should be recreated..
        /// </summary>
        public static string T_Downlevel_Solution {
            get {
                return ResourceManager.GetString("T_Downlevel_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Downlevel trust is a special kind of trust compatible with NT4. The kind of trust can be displayed in the &quot;Active Directory Domains and Trusts&quot; tool..
        /// </summary>
        public static string T_Downlevel_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_Downlevel_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for trusts compatible with NT4.
        /// </summary>
        public static string T_Downlevel_Title {
            get {
                return ResourceManager.GetString("T_Downlevel_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that a compromised domain cannot use file deployed by GPO to compromise other domains.
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Description {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Server: {0} GPO: {1} File: {2}.
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Detail {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Documentation {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of files deployed hosted in another domain: {count}.
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Rationale {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpodeployedfiles&quot;&gt;GPO Deployed Files&lt;/a&gt;.
        /// </summary>
        public static string T_FileDeployedOutOfDomain_ReportLocation {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Copy the file to a share located inside the domain and not in trusted domains..
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Solution {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Files deployed (Applications as msi, file copied by GPO, ...) can be stored in any file share available in the network and that includes trusted domains shares. If such file is located in a compromised domain, it can be used to compromise other domains..
        /// </summary>
        public static string T_FileDeployedOutOfDomain_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if files deployed may be located in a trusted domain.
        /// </summary>
        public static string T_FileDeployedOutOfDomain_Title {
            get {
                return ResourceManager.GetString("T_FileDeployedOutOfDomain_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to verify that every trust has a remote domain which is active..
        /// </summary>
        public static string T_Inactive_Description {
            get {
                return ResourceManager.GetString("T_Inactive_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trust: {0}.
        /// </summary>
        public static string T_Inactive_Detail {
            get {
                return ResourceManager.GetString("T_Inactive_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows/win32/adschema/a-whenchanged.
        /// </summary>
        public static string T_Inactive_Documentation {
            get {
                return ResourceManager.GetString("T_Inactive_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one inactive trust has been found: {count}.
        /// </summary>
        public static string T_Inactive_Rationale {
            get {
                return ResourceManager.GetString("T_Inactive_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#discovereddomains&quot;&gt;Trusts section&lt;/a&gt;.
        /// </summary>
        public static string T_Inactive_ReportLocation {
            get {
                return ResourceManager.GetString("T_Inactive_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for network connectivity issues from the remote domain or if the remote domain still exists. If it doesn&apos;t exist anymore, the trust should be removed. Otherwise, the secret used by the trust can be used to issue fake Kerberos tickets and be used as a backdoor..
        /// </summary>
        public static string T_Inactive_Solution {
            get {
                return ResourceManager.GetString("T_Inactive_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a trust is active, it is using a shared secret to communicate to a domain. This secret is hold in a special account whose name is the remote domain name. This password is changed every month and as consequence the whenChanged attribute of this account is changed. When there is no modification of the whenChanged attribute, it can be guessed that the secret has not been changed and that there was either a problem with the remote domain or that the remote domain does not exist anymore..
        /// </summary>
        public static string T_Inactive_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_Inactive_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for inactive trusts.
        /// </summary>
        public static string T_Inactive_Title {
            get {
                return ResourceManager.GetString("T_Inactive_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that a compromised domain cannot use scripts located in it to compromise other domains.
        /// </summary>
        public static string T_ScriptOutOfDomain_Description {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Script: {0}.
        /// </summary>
        public static string T_ScriptOutOfDomain_Detail {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string T_ScriptOutOfDomain_Documentation {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of login scripts hosted in another domain: {count}.
        /// </summary>
        public static string T_ScriptOutOfDomain_Rationale {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#gpologin&quot;&gt;GPO Login script&lt;/a&gt; and in &lt;a href=&quot;#logonscripts&quot;&gt;Logon Scripts&lt;/a&gt;.
        /// </summary>
        public static string T_ScriptOutOfDomain_ReportLocation {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Copy the login script to a share located inside the domain and not in trusted domains..
        /// </summary>
        public static string T_ScriptOutOfDomain_Solution {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Login scripts can be stored in any file share available in the network and that includes trusted domains shares. If a login script is located in a compromise domain, it can be used to compromise other domains..
        /// </summary>
        public static string T_ScriptOutOfDomain_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if login scripts may be located in a trusted domain.
        /// </summary>
        public static string T_ScriptOutOfDomain_Title {
            get {
                return ResourceManager.GetString("T_ScriptOutOfDomain_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to check if all trusts are protected using the functionality named SID Filtering.
        /// </summary>
        public static string T_SIDFiltering_Description {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trust: {0}.
        /// </summary>
        public static string T_SIDFiltering_Detail {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-103dd7c66280.
        /// </summary>
        public static string T_SIDFiltering_Documentation {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of trusts without SID Filtering: {count}.
        /// </summary>
        public static string T_SIDFiltering_Rationale {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#discovereddomains&quot;&gt;Trusts section&lt;/a&gt;.
        /// </summary>
        public static string T_SIDFiltering_ReportLocation {
            get {
                return ResourceManager.GetString("T_SIDFiltering_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A trust without SID Filtering means either that a migration is in progress or that the domain can be compromised instantly via the trust.
        ///The solution is to complete existing migration ASAP and enable the SID Filtering feature.
        ///
        ///If the trust is a domain trust, you should use netdom /quarantine and set it to yes.
        ///If the trust is a forest trust, you should use netdom /enablesidhistory and set it to no.
        ///Do not apply /quarantine on a forest trust: you will break the transitivity of the trust..
        /// </summary>
        public static string T_SIDFiltering_Solution {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SID Filtering is a mechanism used to block account presenting a SID History property. SID History is used to link an existing account to another account and can be used to propagate a compromise through trusts. SID Filtering for domain-to-domain trust is called a quarantine and is disabled by default. SID Filtering to a forest is enabled by default and disabling it is called &quot;enabling SID History&quot;.
        ///
        ///The algorithm to compute the SID Filtering is:
        ///get the attribute trustDirection and TrustAttributes of the [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_SIDFiltering_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_SIDFiltering_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for Trusts whose security is not maximum.
        /// </summary>
        public static string T_SIDFiltering_Title {
            get {
                return ResourceManager.GetString("T_SIDFiltering_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that the dangerous SID are not stored in the SIDHistory attribute..
        /// </summary>
        public static string T_SIDHistoryDangerous_Description {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Domain: {0}.
        /// </summary>
        public static string T_SIDHistoryDangerous_Detail {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-identifiers.
        /// </summary>
        public static string T_SIDHistoryDangerous_Documentation {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Number of dangerous SID in SIDHistory: {count}.
        /// </summary>
        public static string T_SIDHistoryDangerous_Rationale {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt; and a quick summary in &lt;a href=&quot;#sidhistory&quot;&gt;SID History&lt;/a&gt;.
        /// </summary>
        public static string T_SIDHistoryDangerous_ReportLocation {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///      Identify the account, computer or group having these dangerous SID set in SID History, then clean it up by editing directly the SIDHistory attribute of the underlying AD object.
        ///      
        ///To remove the SIDHistory from a user account, run:
        ///&lt;i&gt;Get-ADUser USERNAME -properties sidhistory | foreach {Set-ADUser $_ -remove @{sidhistory=$_.sidhistory.value}}&lt;/i&gt;
        ///For a group, run:
        ///&lt;i&gt;Get-ADGroup GROUPNAME -properties sidhistory | foreach {Set-ADGroup $_ -remove @{sidhistory=$_.sidhistory.value}}&lt;/i&gt;
        ///For a [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_SIDHistoryDangerous_Solution {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SID History is an attribute used in migration to link with a former account.
        ///    This rule checks for SID not coming from a former domain (such as SYSTEM) or from a former domain but having a RID (the last part of the SID) lower than 1000.
        ///    Indeed, native privileged accounts have a SID lower than 1000.
        ///    A list of Well Known SID is referenced in the documentation below.
        ///    .
        /// </summary>
        public static string T_SIDHistoryDangerous_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if dangerous SID are stored in the SIDHistory attribute..
        /// </summary>
        public static string T_SIDHistoryDangerous_Title {
            get {
                return ResourceManager.GetString("T_SIDHistoryDangerous_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that accounts are not linked for more privileged accounts in the same domain.
        /// </summary>
        public static string T_SIDHistorySameDomain_Description {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string T_SIDHistorySameDomain_Documentation {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Account(s) with SID History matching the domain = {count}.
        /// </summary>
        public static string T_SIDHistorySameDomain_Rationale {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt; and a quick summary in &lt;a href=&quot;#sidhistory&quot;&gt;SID History&lt;/a&gt;.
        /// </summary>
        public static string T_SIDHistorySameDomain_ReportLocation {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is not possible to have this occurrence except if a user from domain A has been migrated to domain B and then migrated again to domain A. This should be strongly investigated as it may be linked to a compromise of the domain.
        ///    
        ///To remove the SIDHistory from a user account, run:
        ///&lt;i&gt;Get-ADUser USERNAME -properties sidhistory | foreach {Set-ADUser $_ -remove @{sidhistory=$_.sidhistory.value}}&lt;/i&gt;
        ///For a group, run:
        ///&lt;i&gt;Get-ADGroup GROUPNAME -properties sidhistory | foreach {Set-ADGroup $_ -remove @{si [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_SIDHistorySameDomain_Solution {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SID History is an attribute used in migration to link with a former account. It is not possible to have an account linked with an account belonging to the same domain. This can be analyzed by comparing the domain part of the SID History with the domain SID..
        /// </summary>
        public static string T_SIDHistorySameDomain_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check for local backdoor stored in SID History.
        /// </summary>
        public static string T_SIDHistorySameDomain_Title {
            get {
                return ResourceManager.GetString("T_SIDHistorySameDomain_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that every account having an SID History is part of an active migration..
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Description {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SID: {0} Object(s): {1}.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Detail {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to .
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Documentation {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {count} unknown domain(s) used in SIDHistory.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Rationale {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SIDHistory detail can be found in &lt;a href=&quot;#useraccountanalysis&quot;&gt;User information&lt;/a&gt; and &lt;a href=&quot;#computeraccountanalysis&quot;&gt;Computer information&lt;/a&gt; and a quick summary in &lt;a href=&quot;#sidhistory&quot;&gt;SID History&lt;/a&gt;.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_ReportLocation {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Each security descriptor of the domain (including file shares for example) should be reviewed to be rewritten with the new SID of the account. Then the SID History attribute should be removed. 
        ///    
        ///    Please note that once the SID History has been removed, it cannot be added back again without doing a real migration. Possibly hacking tools such as mimikatz could be used to undo a deletion with for example the lsadump::dcshadow attack.
        ///  
        ///To remove the SIDHistory from a user account, run:
        ///&lt;i&gt;Get-ADUse [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Solution {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When accounts are migrated from one domain to another, the attribute SID History can be appended to the new account to keep track of its former account. The origin can be tracked by removing the last digit of the SID to guess the SID of the origin domain. If the SID of the origin domain cannot be resolved, that means that the domain has been removed and as consequence that the SID History is not needed. This SID History information can be used to give additional rights and thus alter the real security right [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if the account has been migrated from a domain which doesn&apos;t exist anymore.
        /// </summary>
        public static string T_SIDHistoryUnknownDomain_Title {
            get {
                return ResourceManager.GetString("T_SIDHistoryUnknownDomain_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The purpose is to ensure that a forest cannot be used to compromise another forest using Kerberos delegation.
        /// </summary>
        public static string T_TGTDelegation_Description {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trust: {0}.
        /// </summary>
        public static string T_TGTDelegation_Detail {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to http://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/
        ///https://techcommunity.microsoft.com/t5/Premier-Field-Engineering/Changes-to-Ticket-Granting-Ticket-TGT-Delegation-Across-Trusts/ba-p/440283/tab/rich
        ///https://support.microsoft.com/en-us/help/4490425/updates-to-tgt-delegation-across-incoming-trusts-in-windows-server.
        /// </summary>
        public static string T_TGTDelegation_Documentation {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Documentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At least one forest trust has been found where TGT delegation over forest trust is allowed.
        /// </summary>
        public static string T_TGTDelegation_Rationale {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Rationale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The detail can be found in &lt;a href=&quot;#discovereddomains&quot;&gt;Trusts section&lt;/a&gt;.
        /// </summary>
        public static string T_TGTDelegation_ReportLocation {
            get {
                return ResourceManager.GetString("T_TGTDelegation_ReportLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TGT Delegation on forest trusts should be disabled, except for migrations.
        ///You can use netdom to turn the TGT delegation on forest trust OFF.
        ///Example: netdom.exe trust fabrikam.com /domain:contoso.com /EnableTGTDelegation:No
        ///As an alternative, you can locate the forest trust and change its LDAP trustattribute from the value 8 to the value 520.
        ///
        ///The impact is to have non working services which relies on unconstrained delegation. Resource based delegation is not impacted.
        ///
        ///See the official Microsoft re [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_TGTDelegation_Solution {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Solution", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Forest trust is a link between two forests. By default, this trust is secure and prohibits SID History attacks.
        ///However, it allows Kerberos delegation by default.
        ///By configuring an uncontrainst delegation on forest A, an attacker located in forest A can collect admin or domain controller credentials, the TGT of the session, of the forest B.
        ///This collection can be forced by using services such as the Print Spooler, enabled by default on all domain controllers.
        ///Having collected this TGT, the attacker ca [rest of string was truncated]&quot;;.
        /// </summary>
        public static string T_TGTDelegation_TechnicalExplanation {
            get {
                return ResourceManager.GetString("T_TGTDelegation_TechnicalExplanation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check if Kerberos delegation can be used to take control of the forest from a trusted forest.
        /// </summary>
        public static string T_TGTDelegation_Title {
            get {
                return ResourceManager.GetString("T_TGTDelegation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Administrators grant sometimes privileged rights to colleagues without any approval from a security officer..
        /// </summary>
        public static string TemporaryAdmins_Detail {
            get {
                return ResourceManager.GetString("TemporaryAdmins_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The link with Azure Systems may create new compromise methods between the cloud and on-premise systems..
        /// </summary>
        public static string TrustAzure_Detail {
            get {
                return ResourceManager.GetString("TrustAzure_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A trust is a technical boundary which should not be altered..
        /// </summary>
        public static string TrustImpermeability_Detail {
            get {
                return ResourceManager.GetString("TrustImpermeability_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Any trust introduces a risk. The secret used for the trust can be exposed to take control of the domain..
        /// </summary>
        public static string TrustInactive_Detail {
            get {
                return ResourceManager.GetString("TrustInactive_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Patching computers is part of the security process. Unpatched vulnerability is a way to gain control of a computer..
        /// </summary>
        public static string VulnerabilityManagement_Detail {
            get {
                return ResourceManager.GetString("VulnerabilityManagement_Detail", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Misprotected credentials can be abused to be retrieved in plain text and then, impersonate the user..
        /// </summary>
        public static string WeakPassword_Detail {
            get {
                return ResourceManager.GetString("WeakPassword_Detail", resourceCulture);
            }
        }
    }
}
